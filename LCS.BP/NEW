*---> Recovered document: ALL.PROGS.TXT
     PROGRAM UPCASE.FILE
     LM = 0
     FILE.NAME = TRIM(FIELD(@SENTENCE," ",2))
     ITEM.NAME = TRIM(FIELD(@SENTENCE," ",3))
     SELECT.STR = "SELECT ":FILE.NAME
     IF ITEM.NAME THEN SELECT.STR := " ":ITEM.NAME
     IF LM THEN PRINT SELECT.STR
     EXECUTE SELECT.STR CAPTURING CAP
     LOOP WHILE READNEXT ITEM DO
          UP.ITEM = UPCASE(ITEM)
          DOS.CMD = "CNAME ":FILE.NAME:" ":ITEM:" TO ":UP.ITEM:"001"
          IF LM THEN PRINT DOS.CMD
          EXECUTE DOS.CMD CAPTURING CAP
          DOS.CMD = "CNAME ":FILE.NAME:" ":UP.ITEM:"001 TO ":UP.ITEM
          IF LM THEN PRINT DOS.CMD
          EXECUTE DOS.CMD CAPTURING CAP
     REPEAT



     OPEN 'RULES' TO RULES ELSE PRINT 'RULES';STOP
     OPEN 'TRANS.U' TO TRANS ELSE PRINT 'TRANS.U';STOP
     RULE.NUM = 1001
     RULE.EXP = "D=VETE;N:Chelsea Veterinary,C:Pet Expense"
     CALL RUN.RULE(RULES,TRANS,RULE.EXP,RULE.NUM)

     DEFFUN GET.FILE.PROPS(INARGS)
     INARGS = ""
     INARGS<1> = '"C:\U2\UV\ACCOUNTS\DDI\LCS.BP"'
     INARGS<3> = 'LASTWRITETIME,LENGTH'

     PRINT GET.FILE.PROPS(INARGS)


     * Will Johnson
     * Variables passed in, there is nothing that must be passed in, but
     * Optionally assign PASS.ERROR to TRUE or FALSE.
     *    PASS.ERROR = TRUE means it is OK to assign ERROR here, but don't
     *                 display it here, just pass it back
     *
     * Variables passed out
     * SENTENCE is set to @SENTENCE
     * ERROR is set to any error generated here
     * C.WORD is set to the word position number of the command line
     * T2.VERB is set to RUN or RAID if that is the first word, otherwise
     *    T2.VERB is set to null
     * T2.FILE is set to the program file that is being RUN or RAID, if that
     *    is the first word, otherwise T2.FILE is set to null
     * I.AM is the verb / program with this include in it, this will be the
     *    third word if being RUN or RAID, otherwise the first word
     * N.FILE is the text name of the file being acted upon
     *    This is passed back as [DICT] filename[,mlfile]
     * F.FILE is the file pointer to the N.FILE
     * DICT.FLAG is set to TRUE if N.FILE is a DICT, otherwise FALSE
     * MULTI.LEVEL is set to TRUE if N.FILE is a multi-level file reference,
     *    otherwise FALSE
     * DF.FILE is the file pointer to the DICT of the N.FILE, or if the
     *    N.FILE is itself a DICT, then it points to the VOC
     *
     *
     SENTENCE = @SENTENCE
     IF NOT(ASSIGNED(PASS.ERROR)) THEN PASS.ERROR = FALSE
     *ERROR =
     *
     C.WORD = 1 ; FIRST.WORD = FIELD(SENTENCE,' ',C.WORD)
     IF FIRST.WORD MATCHES "RUN":@VM:"RAID" THEN
          T2.VERB = FIRST.WORD
          C.WORD += 1 ; T2.FILE = FIELD(SENTENCE,' ',C.WORD)
          C.WORD += 1 ; I.AM = FIELD(SENTENCE,' ',C.WORD)
     END ELSE T2.VERB = "" ; T2.FILE = "" ; I.AM = FIRST.WORD
     C.WORD += 1 ; N.FILE = FIELD(SENTENCE,' ',C.WORD)
     C.FILEEND = COL2()
     *
     BEGIN CASE
          CASE N.FILE = "DICT"
               C.WORD += 1 ; N.FILE = "DICT ":FIELD(SENTENCE,' ',C.WORD)
               C.FILEEND = COL2()
          CASE N.FILE = "DATA"
               C.WORD += 1 ; N.FILE = "DATA ":FIELD(SENTENCE,' ',C.WORD)
               C.FILEEND = COL2()
          CASE N.FILE =
               PRINT "FILE: ": ; INPUT N.FILE
               IF N.FILE =  THEN
                    IF PASS.ERROR THEN
                         ERROR = 'No file entered' ; GOTO TCL.II.EXIT
                    END ELSE STOP
               END
     END CASE
     *
     * Can handle files entered as:
     *    CUSTOMER,10-11; CUSTOMER; DICT CUSTOMER; DATA CUSTOMER
     *
     DICT.FLAG = FALSE ; MULTI.LEVEL = FALSE
     BEGIN CASE
          CASE INDEX(N.FILE,",",1)        ; *MULTI-LEVEL FILE
               MULTI.LEVEL = TRUE
               N2.FILE = FIELD(N.FILE,",",2)
               N.FILE = FIELD(N.FILE,",",1)
          CASE FIELD(N.FILE," ",1) = "DICT"         ; *DICT FILE
               DICT.FLAG = TRUE
               N.FILE = FIELD(N.FILE," ",2)
          CASE FIELD(N.FILE," ",2) = "DATA"         ; *DATA THROW-AWAY
               N.FILE = FIELD(N.FILE," ",2)
          CASE 1                          ; *NORMAL FILE
     END CASE
     *
     IF DICT.FLAG THEN
          OPEN "VOC" TO DF.FILE ELSE ERR = 'VOC' ; GOTO FILE.ERROR
     END ELSE
          OPEN "DICT",N.FILE TO DF.FILE ELSE
               ERR = 'DICT ':N.FILE ; GOTO FILE.ERROR
          END
     END
     IF MULTI.LEVEL THEN N.FILE = N.FILE:",":N2.FILE
     IF DICT.FLAG THEN N.FILE = "DICT ":N.FILE
     OPEN N.FILE TO F.FILE ELSE ERR = N.FILE ; GOTO FILE.ERROR
     *
     GOTO TCL.II.EXIT
     *
FILE.ERROR:
     ERROR = 'Cannot open ':ERR:' file.'
     IF PASS.ERROR THEN
          GOTO TCL.II.EXIT
     END ELSE CRT ERROR:' Hit ENTER': ; INPUT NOTHING ; STOP
     *
TCL.II.EXIT:
     READ SCREEN FROM LCS.CONTROL,"SCREEN" THEN
          B=SCREEN
          GOSUB SHOW.SCREEN
     END
     READ SCREEN2 FROM LCS.CONTROL,"SCREEN2" THEN
          B = SCREEN2
          GOSUB SHOW.SCREEN:
     END
     STOP
SHOW.SCREEN:
     FOR X = 1 TO 500
          A = B[X,1]
          PRINT "(":X:"-":SEQ(A):")  ":A
     NEXT X

     RETURN
     OPEN 'ACCOUNTS' TO ACCOUNTS ELSE STOP
     *OPEN 'ACCOUNTS2' TO ACCOUNTS2 ELSE STOP
     EQU AMT TO BUFF<7>, DEB TO BUFF<9>, CRD TO BUFF<8>, ACC.ID TO BUFF<11>
     EQU A.AMT TO ABUFF<7>, A.DEB TO ABUFF<8>, A.CRD TO ABUFF<9>, ACC.NAME TO ABUFF<1>

     EXECUTE "SELECT ACCOUNTS"
     LOOP WHILE READNEXT AA DO
          READ ABUFF FROM ACCOUNTS,AA THEN
               A.AMT = "0"
               A.DEB = "0"
               A.CRD = "0"
               WRITE ABUFF ON ACCOUNTS,AA
          END
     REPEAT

     EXECUTE "SELECT TRANS"

     CT=0
     LOOP WHILE READNEXT AA DO
          READ BUFF FROM TRANS,AA THEN
               READ ABUFF FROM ACCOUNTS,ACC.ID ELSE ABUFF = ""
               *PRINT "READING ":AA
               *PRINT "  ":BUFF
               *PRINT "  ":ABUFF
               A.AMT += AMT
               A.DEB += DEB
               A.CRD += CRD
               WRITE ABUFF ON ACCOUNTS,ACC.ID
          END
     REPEAT

     EXECUTE "TERM 140,55"
     EXECUTE "SORT ACCOUNTS BY ACCT.ID WITH AMT <> 0 ACCT.ID ACCOUNT.NAME AMT DEB CRD ID-SUPP HDR.SUP"
     STOP

     LOOP WHILE READNEXT AA DO
          READ ABUFF FROM ACCOUNTS,AA THEN
               PRINT AA "L#6 ":ACC.NAME "L#40 ":A.DEB "R#10 ":A.CRD "R#10": A.AMT "R#10"
          END
     REPEAT



     *---> Recovered document: SUBMIT.FILE
     SUBROUTINE GET.PRICE.SOURCE.PARAMETERS(XMISC,ERRORS)

     $OPTIONS DEFAULT STATIC.DIM

     ERRORS = ""
     OUTARGS = ""
     LM=1
     IF LM THEN PRINT "*** STARTING SUBMIT.FILE ":XMISC
     **I2.PRICE.UPDATE.LOG
     EQU  UPDATE.TYPE TO XMISC<1>, UPDATEID TO XMISC<2>, USER TO XMISC<3>, UPDATE.NUM TO XMISC<4>
     EQU UPDATE.CODE TO XMISC<5>,  UPDATE.NAME TO XMISC<6>
     EQU NOTE TO XMISC<7>, MAST.EFFDATE TO XMISC<8>, MAST.EXPDATE TO XMISC<9>, UPDATE.MODE TO XMISC<10>
     EQU UPDATE.SCOPE TO XMISC<11>
     EQU FILE.NAME TO XMISC<12,1>, FILE.PATH TO XMISC<12,2>, ITEM.NAME TO XMISC<13>
     EQU DELIM TO XMISC<14>
     EQU COL.LABELS TO XMISC<15>, COL.VALUES TO XMISC<16>
     EQU UPC.COL TO XMISC<16,1>, CAT.COL TO XMISC<16,2>, EFFDATE.COL TO XMISC<16,3>,COST.COL TO XMISC<16,4>, UOM.COL TO XMISC<16,5>
     EQU HEADER.LABELS TO XMISC<17>, HEADER.VALUES TO XMISC<18>
     EQU UPC.FORMAT TO XMISC<18,1>, DATA.START TO XMISC<18,2>
     EQU CUSTOM.SUB TO XMISC<19>
     EQU MAST.UOM TO XMISC<20>
     EQU RUN.COUNT TO XMISC<21>
     EQU V.NUM TO XMISC<22>, V.NAME TO XMISC<23>, V.NEW TO XMISC<24>
     EQU V.UPDATE TO XMISC<25>, V.DELETE TO XMISC<26>, V.ZAP TO XMISC<27>
     EQU V.TOTAL TO XMISC<28>
     EQU T.NEW TO XMISC<29>, T.UPDATE TO XMISC<30>, T.DELETE TO XMISC<31>
     EQU T.ZAPPED TO XMISC<32>, T.TOTAL TO XMISC<33>


     COL.LAB=""
     COL.LAB<1>='COL.LETTER'       :@VM:'CORRESPONDING LETTER ON A SPREADSHEET FOR THE COL'
     COL.LAB<2>='COL.NUMBER'      :@VM:'ORDINAL POSITION OF NON EMPTY COLUMN ON SPREADSHEET'
     COL.LAB<3>='COL.NUM.USED'    :@VM:'ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS'
     COL.LAB<4>='NAMES'            :@VM:'UPC, COST, UOM, C1.COST, EFFDATE'
     COL.LAB<5>='CURRENCY.QTY'     :@VM:'QTY OF VALUES CONSISTENT WITH CURRENCY'
     COL.LAB<6>='CURRENCY.LOW'     :@VM:'LOWEST VALUE IN COLUMN THAT IS  CURRENCY'
     COL.LAB<7>='CURRENCY.HIGH'    :@VM:'HIGHEST VALUE IN COLUMN THAT IS CURRENCY'
     COL.LAB<8>='CURRENCY.TOTAL'   :@VM:'SUM OF ALL CURRENCY VALUES IN COLUMN'
     COL.LAB<9>='CURRENCY.AVG'     :@VM:'AVERAGE OF CURRENCY VALUES FOUND IN COLUMN'
     COL.LAB<10>='UOM.QTY'          :@VM:'QTY OF VALUES CONSISTENT WITH UOM'
     COL.LAB<11>='LENGTHS'         :@VM:'ARRAY OF LENGTHS FOUND IN COLUMN'
     COL.LAB<12>='LENGTHS.QTY'     :@VM:'QTY OF ROWS WITH LENGTHS'
     COL.LAB<13>='MIN.LEN'         :@VM:'MIN LENGTH OF VALUE FOUND IN COLUMN'
     COL.LAB<14>='MAX.LEN'          :@VM:'MAX LENGTH OF VALUE FOUND IN COLUMN'
     COL.LAB<15>='LEN.POP'         :@VM:'MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH'
     COL.LAB<16>='LEN.POP.QTY'     :@VM:'NUM OF ROWS WITH MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH'
     COL.LAB<17>='LEN.TOTAL'       :@VM:'TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
     COL.LAB<18>='ALPHA'           :@VM:'QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC'
     COL.LAB<19>='DATE.OLDEST'     :@VM:'OLDEST DATE VALUE FOUND IN COLUMN'
     COL.LAB<20>='DATE.NEWEST'     :@VM:'NEWEST DATE VALUE FOUND IN COLUMN'
     COL.LAB<21>='DATE.QTY'        :@VM:'QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE'
     COL.LAB<22>='DATE.FORMAT'     :@VM:'FORMAT OF THE DATES FOUND IN THE DATA'
     COL.LAB<23>='NUM.ONLY'        :@VM:'QTY OF VALUES THAT ARE PURE NUMBERS'
     COL.LAB<24>='NUM.HIGH'        :@VM:'HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER'
     COL.LAB<25>='NUM.LOW'         :@VM:'LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER'
     COL.LAB<26>='NUM.TOTAL'       :@VM:'SUM OF VALUES THAT ARE NUM ONLY IN COLUMN'
     COL.LAB<27>='NUM.AVG'         :@VM:'AVG OF VALUES THAT ARE NUM ONLY IN COLUMN'
     COL.LAB<28>='EMPTY.QTY'       :@VM:'QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN'
     COL.LAB<29>='OCCUPIED.QTY'    :@VM:'QTY OF VALUES THAT ARE NOT EMPTY'
     COL.LAB<30>='CELL.DATA'       :@VM:'ARRAY OF VALUES IN COLUMN'
     COL.LAB<31>='PRED.TYPE.QTY'   :@VM:'QTY OF ROWS WITH PREDOMINANT CELL TYPE'
     COL.LAB<32>='CELL.TYPES'   :@VM:'ARRAY OF CELL TYPES FOUND IN COLUMN'
     COL.LAB<33>='CELL.TYPES.QTY'  :@VM:'ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE'
     COL.LAB<34>='PRED.TYPE'       :@VM:'PREDOMINANT TYPE OF VALUE IN THE COLUMN.  TYPES OF VALUES IN EACH CELL ARE: $,9,A,0,D,U,S,#,C (CURRENCY, NUMBER ONLY, ALPHA ONLY, EMPTY, DATE, UOM, ALPHA NUMERIC STRING, UPC, CAT.COL)'

     EQU COL.LETTER.A TO 1          ;* CORRESPONDING LETTER ON A SPREADSHEET FOR THE COL
     EQU COL.NUMBER.A TO 2          ;* ORDINAL POSITION OF NON EMPTY COLUMN ON SPREADSHEET
     EQU COL.NUM.USED.A TO 3          ;* ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS
     EQU NAMES.A TO 4               ;* UPC, COST, UOM, C1.COST, EFFDATE
     EQU CURRENCY.QTY.A TO 5          ;* QTY OF VALUES CONSISTENT WITH CURRENCY
     EQU CURRENCY.LOW.A TO 6          ;* LOWEST VALUE IN COLUMN THAT IS  CURRENCY
     EQU CURRENCY.HIGH.A TO 7      ;* HIGHEST VALUE IN COLUMN THAT IS CURRENCY
     EQU CURRENCY.TOTAL.A TO 8     ;* SUM OF ALL CURRENCY VALUES IN COLUMN
     EQU CURRENCY.AVG.A TO 9          ;* AVERAGE OF CURRENCY VALUES FOUND IN COLUMN
     EQU UOM.QTY.A TO 10           ;* QTY OF VALUES CONSISTENT WITH UOM
     EQU LENGTHS.A TO 11           ;* ARRAY OF LENGTHS FOUND IN COLUMN
     EQU LENGTHS.QTY.A TO 12           ;* QTY OF ROWS WITH LENGTHS
     EQU MIN.LEN.A TO 13           ;* MIN LENGTH OF VALUE FOUND IN COLUMN
     EQU MAX.LEN.A TO 14           ;* MAX LENGTH OF VALUE FOUND IN COLUMN
     EQU LEN.POP.A TO 15           ;* MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH
     EQU LEN.POP.QTY.A TO 16           ;* NUM OF ROWS WITH MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH
     EQU LEN.TOTAL.A TO 17           ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS
     EQU ALPHA.A TO 18                ;* QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC
     EQU DATE.OLDEST.A TO 19           ;* OLDEST DATE VALUE FOUND IN COLUMN
     EQU DATE.NEWEST.A TO 20           ;* NEWEST DATE VALUE FOUND IN COLUMN
     EQU DATE.QTY.A TO 21           ;* QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE
     EQU DATE.FORMAT.A TO 22           ;* FORMAT OF THE DATES FOUND IN THE DATA
     EQU NUM.ONLY.A TO 23           ;* QTY OF VALUES THAT ARE PURE NUMBERS
     EQU NUM.HIGH.A TO 24           ;* HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER
     EQU NUM.LOW.A TO 25           ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
     EQU NUM.TOTAL.A TO 26           ;* SUM OF VALUES THAT ARE NUM ONLY IN COLUMN
     EQU NUM.AVG.A TO 27           ;* AVG OF VALUES THAT ARE NUM ONLY IN COLUMN
     EQU EMPTY.QTY.A TO 28           ;* QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN
     EQU OCCUPIED.QTY.A TO 29      ;* QTY OF VALUES THAT ARE NOT EMPTY
     EQU CELL.DATA.A TO 30           ;* ARRAY OF VALUES IN COLUMN
     EQU PRED.TYPE.QTY.A TO 31      ;* QTY OF ROWS WITH PREDOMINANT CELL TYPE
     EQU CELL.TYPES.A TO 32           ;* ARRAY OF CELL TYPES FOUND IN COLUMN
     EQU CELL.TYPES.QTY.A TO 33      ;* ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE
     EQU PRED.TYPE.A TO 34           ;* PREDOMINANT TYPE OF VALUE IN THE COLUMN.  TYPES OF VALUES IN EACH CELL ARE

     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL';STOP
     OPEN 'CONTROL' TO F.CONTROL ELSE PRINT 'CONTROL';STOP
     OPEN 'DICT','I2.PRODUCT.SOURCE' TO D.I2PS ELSE PRINT 'DICT I2.PRODUCT.SOURCE';STOP

     READV I2.PATH FROM LCS.CONTROL,"I2.PATH",1 ELSE I2.PATH = "E:\DATA_ACCOUNTS\PRICE\"
     PRICE.SOURCE.NAME = ITEM.NAME


     IF NOT(ERRORS) THEN
          GOSUB INITIALIZE:
          GOSUB GET.SAMPLE.ROWS:
          GOSUB GET.FIELD.DELIMETER.AND.COLS:
          GOSUB ANALYZE.HEADING:
          GOSUB INITIALIZE.COL.METADATA:
          GOSUB ANALYZE.SAMPLE.CELLS:
          GOSUB ANALYZE.VENDOR:
          GOSUB ANALYZE.COLUMNS:
          GOSUB PARSE.MAP:
          GOSUB CHECK.ERRORS:
     END

     IF LM THEN PRINT "*** FINISHING SUBMIT.FILE ":XMISC


     RETURN

INITIALIZE:
     IF LM THEN PRINT "*** INITIALIZE"
     FALSE = 0
     TRUE = 1
     EOF = FALSE
     MAX.ROWS = 80
     MAX.COLS = 0
     ASCII.ALPHA = 64
     DATES.LIST = ""
     PROVIDED.MAP = TRUE


     DELIMETER = ""


     *FIELD DELIMETERS (POSSIBLE) THAT WE TEST OUR FILE FOR
     DELIMETER.P = ""
     DELIMETER.P<1> = CHAR(9);DELIMETER.P<1,2>="TAB"
     DELIMETER.P<2> = ",";DELIMETER.P<2,2>="COMMA"
     DELIMETER.P<4> = ":";DELIMETER.P<4,2>="COLON"
     DELIMETER.P.COUNT = DCOUNT(DELIMETER.P,@FM)
     *
     **POSSIBLE DATE FORMATS TO TEST FOR
     DF = ""
     DF<1> = "D2/"
     DF<2> = "D4/"
     DF<3> = "DI"
     DF<4> = "D2-"
     DF<5> = "D"
     DF<6> = "D2"
     DF<7> = "D/E"
     DF.COUNT = DCOUNT(DF,@FM)

     * POSSIBLE UNITS OF MEASURE
     UM = ""
     UM<1> = "EA"
     UM<2> = "E"
     UM<3> = "C"
     UM<4> = "M"
     UM<5> = "HU"
     UM<6> = "FT"
     UM<7> = "TH"
     UM<8> = "DZ"
     UM.COUNT = DCOUNT(UM,@FM)

     * POSSIBLE COLUMN TYPES
     CT = "$,9,A,0,D,U,S,#,C"
     CT = CHANGE(CT," ",CHAR(254))
     CT.COUNT = DCOUNT(CT,CHAR(254))


     * POSSIBLE VENDORS
     VEND.NUMS = ""
     UPDATE.NAMES = ""
     UPDATE.CODES = ""
     OPEN 'TS.VEND' TO TS.VEND ELSE PRINT 'TS.VEND';STOP
     SELECT TS.VEND
     READLIST VENDOR.NUMS ELSE ERRORS<-1> = "NO VENDORS FOUND IN TS.VEND"
     IF NOT(ERRORS) THEN
          VEND.COUNT = DCOUNT(VENDOR.NUMS,@FM)
          FOR VEND.X = 1 TO VEND.COUNT
               VEND.NUM = VENDOR.NUMS<VEND.X>
               READ VEND.B FROM TS.VEND,VEND.NUM THEN
                    UPDATE.NAMES<-1> = VEND.B<1>
                    UPDATE.CODES<-1> = VEND.B<2>
               END
          NEXT VEND.X
     END
     *
     ***INITIALIZE RETURNING VARIABLES
     *UPDATE.CODE = ""
     *VEND.NUMBER = ""
     *UPDATE.NAME = ""
     *USER.NAME = ""
     MAST.UOM1 = ""
     *MAST.EFFDATE = ""
     *MAST.EXPDATE = ""
     *NOTE = ""
     *UPC.COL = ""
     *UPC.FORMAT = ""
     *CAT.COL = ""
     *EFFDATE.COL = ""
     *EXPDATE.COL = ""
     *COST.COL = ""
     *C1.COST.COL = ""
     MAX.COLS = ""
     *DELIM = ""
     *UOM.COL = ""
     *DATA.START = 0

     RETURN


GET.SAMPLE.ROWS:
     IF LM THEN PRINT "***GET.SAMPLE.ROWS"
     DIM ROW(MAX.ROWS)
     IF FILE.PATH THEN
          PRICE.SOURCE.PATH = FILE.PATH:PRICE.SOURCE.NAME
          IF LM THEN PRINT "OPENING ":PRICE.SOURCE.NAME:" TO "
          OPENSEQ PRICE.SOURCE.PATH TO PRICE.FILE ELSE PRINT "UNABLE TO OPEN FILE ":PRICE.SOURCE.PATH;STOP
     END ELSE
          IF (FILE.NAME AND ITEM.NAME) THEN
               OPENSEQ FILE.NAME,ITEM.NAME TO PRICE.FILE ELSE PRINT 'UNABLE TO OPEN ITEM ':ITEM.NAME:' IN FILE ':FILE.NAME;STOP
          END ELSE ERRORS<-1> = 'SOURCE DATA FILE NOT SPECIFIED'
     END
     EOF = FALSE
     MAT ROW = ""

     FOR ROW.NUM = 1 TO MAX.ROWS
          READSEQ ROW(ROW.NUM) FROM PRICE.FILE ELSE EOF = TRUE
     UNTIL EOF
     NEXT ROW.NUM
     IF ROW.NUM < MAX.ROWS THEN MAX.ROWS = ROW.NUM

     IF MAX.ROWS < 5 THEN ERRORS<-1> = "PRICE FILE CONTAINS ONLY ":MAX.ROWS" ROWS OF DATA"
     CLOSESEQ PRICE.FILE
     RETURN




GET.FIELD.DELIMETER.AND.COLS:
     IF LM THEN PRINT "GET.FIELD.DELIMETER.AND.COLS:"
     * TRYING THE COMMON FIELD DELIMETERS UNTIL WE FIND ONE THAT IS MOST PERVASIVE
     MAX.COLS = 0
     FIELD.COUNT.MAX = 0
     FOR DELIMETER.P.X = 1 TO DELIMETER.P.COUNT
          FIELD.COUNT.TOTAL = 0
          MAX.FIELD.COUNT = 0
          FOR ROW.NUM = 1 TO MAX.ROWS
               IF ROW(ROW.NUM)[1,6] <> "***LCS" THEN
                    FIELD.COUNT = DCOUNT(ROW(ROW.NUM),DELIMETER.P<DELIMETER.P.X,1>)
                    FIELD.COUNT.TOTAL += FIELD.COUNT
                    IF FIELD.COUNT > MAX.FIELD.COUNT THEN MAX.FIELD.COUNT = FIELD.COUNT
               END
          NEXT ROW.NUM
          IF FIELD.COUNT.TOTAL > FIELD.COUNT.MAX THEN
               FIELD.COUNT.MAX = FIELD.COUNT.TOTAL
               MAX.COLS = MAX.FIELD.COUNT
               DELIMETER.F = DELIMETER.P<DELIMETER.P.X,1>
               DELIM.F = DELIMETER.P<DELIMETER.P.X,2>
          END
     NEXT DELIMETER.P.X
     IF MAX.COLS < 2 THEN
          ERRORS<-1> = "NO VALID FIELD DELIMETERS RECOGNIZED IN THE FILE"
     END ELSE
          DELIMETER = DELIMETER.F
          DELIM=DELIM.F
     END
     RETURN

ANALYZE.VENDOR:
     IF LM THEN PRINT "*** ANALYZE.VENDOR"
     UPDATE.CODE= FIELD(ITEM.NAME,"_",1)[1,3]
     SELECT.STR = "SELECT TS.VEND WITH ABB = ":UPDATE.CODE
     EXECUTE SELECT.STR
     READLIST VEND.NUMBER THEN
          VEND.NUMBER = VEND.NUMBER<1>
          READ VBUFF FROM TS.VEND,VEND.NUMBER THEN
               UPDATE.NAME = VBUFF<1>
          END
     END
     RETURN



ANALYZE.HEADING:
     IF LM THEN PRINT "ANALYZE.HEADING:"


     DIM CELLS(MAX.ROWS,MAX.COLS)
     MAT CELLS = ""
     DATA.START = 0
     CONSECUTIVE.SAME.LENGTH.COL = 0
     FOR ROW.NUM = 1 TO MAX.ROWS
          SAME.LEN=0
          DATA.LINE = CHANGE(ROW(ROW.NUM),DELIMETER,CHAR(254))
          IF DATA.LINE[1,6] <> "***LCS" THEN
               FOR COL.NUM = 1 TO MAX.COLS
                    CELL.VALUE = DATA.LINE<COL.NUM>
                    WORD.COUNT = DCOUNT(CELL.VALUE," ")
                    FOR WORD.NUM = 1 TO WORD.COUNT
                         WORD = FIELD(CELL.VALUE," ",WORD.NUM)
                         IF NOT(UPDATE.NAME) THEN LOCATE WORD:"]" IN UPDATE.NAMES SETTING POS THEN
                              UPDATE.NAME = UPDATE.NAMES<POS>
                              VEND.NUM = VEND.NUMS<POS>
                              UPDATE.CODE = UPDATE.CODES<POS>
                         END
                         IF ICONV(WORD,'D') THEN DATES.LIST<-1> = ICONV(WORD,'D')
                         LOCATE WORD IN UM<1> SETTING POS THEN MAST.UOM1<-1> = UM<1,POS>
                         MAST.UOM = MAST.UOM1
                    NEXT WORD.NUM
                    CELLS(ROW.NUM,COL.NUM)<1> = CELL.VALUE
                    IF NOT(DATA.START) THEN
                         IF LEN(CELL.VALUE) > 0 THEN
                              IF LEN(CELL.VALUE) = LEN(CELLS(ROW.NUM-1,COL.NUM)<1>) THEN
                                   CONSECUTIVE.SAME.LENGTH.COL<COL.NUM> +=1
                                   IF CONSECUTIVE.SAME.LENGTH.COL<COL.NUM> > 4 THEN DATA.START = ROW.NUM - 5
                              END
                         END
                    END
               NEXT COL.NUM
          END
     NEXT ROW.NUM
     IF DATA.START = 0 THEN
          ERRORS<-1> = "CANNOT FIND COLUMN WITH AT LEAST 5 CONSECUTIVE ROWS WITH THE SAME LENGTH"
     END
     RETURN





INITIALIZE.COL.METADATA:
     IF LM THEN PRINT "INITIALIZE.COL.METADATA:"

     COL.META = ""
     FOR COL.NUM = 1 TO MAX.COLS
          COL.META<COL.NUM,COL.LETTER.A> = ""         ;* CORRESPONDING LETTER ON AN EXCEL SPREADSHEET
          COL.META<COL.NUM,COL.NUMBER.A> = 0          ;* ORDINAL POSITION OF COLUMN ON SPREADSHEET
          COL.META<COL.NUM,COL.NUM.USED.A> = 0        ;* ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS
          COL.META<COL.NUM,NAMES.A> = ""              ;* UPC, COST, UOM, C1.COST, EFFDATE
          COL.META<COL.NUM,CURRENCY.QTY.A> = 0        ;* QTY OF VALUES CONSISTENT WITH CURRENCY
          COL.META<COL.NUM,CURRENCY.LOW.A> = ""       ;* LOWEST VALUE IN COLUMN THAT IS  CURRENCY
          COL.META<COL.NUM,CURRENCY.HIGH.A> = ""      ;* HIGHEST VALUE IN COLUMN THAT IS CURRENCY
          COL.META<COL.NUM,CURRENCY.TOTAL.A> = 0      ;* SUM OF ALL CURRENCY VALUES IN COLUMN
          COL.META<COL.NUM,CURRENCY.AVG.A> = ""       ;* AVERAGE OF CURRENCY VALUES FOUND IN COLUMN
          COL.META<COL.NUM,UOM.QTY.A> = 0             ;* QTY OF VALUES CONSISTENT WITH UOM
          COL.META<COL.NUM,MAX.LEN.A> = 0            ;* MAX LENGTH OF VALUE FOUND IN COLUMN
          COL.META<COL.NUM,MIN.LEN.A> = 0            ;* MIN LENGTH OF VALUE FOUND IN COLUMNHOLD ACTUAL VALUES
          COL.META<COL.NUM,LEN.POP.A> = 0            ;* MOST POPULAR LENGTH OF VALUE FOUND IN COLUMN
          COL.META<COL.NUM,ALPHA.A> = 0               ;* QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC
          COL.META<COL.NUM,DATE.OLDEST.A> = ""        ;* OLDEST DATE VALUE FOUND IN COLUMN
          COL.META<COL.NUM,DATE.NEWEST.A> = ""        ;* NEWEST DATE VALUE FOUND IN COLUMN
          COL.META<COL.NUM,DATE.FORMAT.A> = ""        ;* CONVERSION CODE USED TO INTEREPRET DATE FIELDS
          COL.META<COL.NUM,DATE.QTY.A> = 0            ;* QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE
          COL.META<COL.NUM,NUM.ONLY.A> = 0            ;* QTY OF VALUES IN COLUMN THAT IS A PURE NUMBER
          COL.META<COL.NUM,NUM.HIGH.A> = ""           ;* HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER
          COL.META<COL.NUM,NUM.LOW.A> = ""            ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
          COL.META<COL.NUM,NUM.TOTAL.A> = 0           ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
          COL.META<COL.NUM,NUM.AVG.A> = 0             ;* AVG OF VALUES THAT ARE NUM ONLY IN COLUMN
          COL.META<COL.NUM,EMPTY.QTY.A> = 0           ;* QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN
          COL.META<COL.NUM,OCCUPIED.QTY.A> = 0        ;* QTY OF VALUES THAT ARE NOT EMPTY IN THAT COLUMN
          COL.META<COL.NUM,PRED.TYPE.A> = ""          ;* PREDOMINANT TYPE OF VALUE IN THE COLUMN
          COL.META<COL.NUM,PRED.TYPE.QTY.A> = 0       ;* QTY OF ROWS WITH PREDOMINANT CELL TYPE
          COL.META<COL.NUM,CELL.TYPES.A> = ""         ;* ARRAY OF CELL TYPES FOUND IN COLUMN
          COL.META<COL.NUM,CELL.TYPES.QTY.A> = ""     ;* ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE
          COL.META<COL.NUM,LEN.TOTAL.A> = 0           ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
          COL.META<COL.NUM,CELL.DATA.A> = ""            ;* ARRAY OF VALUES IN COLUMN
          COL.META<COL.NUM,LEN.TOTAL.A> = 0             ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
          COL.META<COL.NUM,LENGTHS.A> = ""              ;* ARRAY OF LENGTHS FOUND IN COLUMN'
          COL.META<COL.NUM,LENGTHS.QTY.A> = ""          ;* QTY OF ROWS WITH LENGTHS
          COL.META<COL.NUM,LEN.POP.QTY.A> = 0            ;* QTY OF ROWS WITH MOST POPULAR LENGTH OF VALUE FOUND IN COLUMN
     NEXT COL.NUM

     RETURN


ANALYZE.SAMPLE.CELLS:
     IF LM THEN PRINT "ANALYZE.SAMPLE.CELLS:"
     *NOW WE ANALYZE OUR SAMPLE TO SEE IF WE CAN MAP THE STRUCTURE OF THE DATA TO COLUMN NUMBERS
     *FIRST WE LOOK AT EACH COLUMN AND TRY TO CHARACTERIZE THE DATA FOR EACH ONE

     FOR COL.NUM = 1 TO MAX.COLS
          TOTAL.LEN = 0
          TOTAL.DATES = 0

          * SPREADSHEET COLUMN LETTER
          COL.META<COL.NUM,COL.LETTER.A> = CHAR(ASCII.ALPHA+COL.NUM)
          * SPREADSHEET COLUMN NUMBER (ORDINAL POSITION)
          COL.META<COL.NUM,COL.NUMBER.A> = COL.NUM
          LAST.COL.NUM.USED = 0
          FOR ROW.NUM = 1 TO MAX.ROWS
               CELL.VALUE = CELLS(ROW.NUM,COL.NUM)<1>
               COL.META<COL.NUM,30,ROW.NUM>=CELL.VALUE
               IF ROW.NUM => DATA.START THEN
                    IF CELL.VALUE THEN
                         * EVALUATE VALUE LENGTH
                         CELL.TYPE=""
                         GOSUB CHECK.LENGTH:
                         IF NOT(COL.META<COL.NUM,COL.NUM.USED.A>) THEN
                              LAST.COL.NUM.USED += 1
                              COL.META<COL.NUM,COL.NUM.USED.A> = LAST.COL.NUM.USED
                         END
                         GOSUB ANALYZE.NUMERIC.ONLY:
                         IF (CELL.TYPE <> "9" AND CELL.TYPE <> '$') THEN
                              GOSUB ANALYZE.ALPHA.ONLY:
                              IF CELL.TYPE = "A" THEN
                                   GOSUB ANALYZE.UOM:
                              END ELSE
                                   GOSUB ANALYZE.DATE
                                   IF CELL.TYPE <> 'D' THEN
                                        CELL.TYPE = "S"
                                        GOSUB SET.ARRAY.CELL:
                                   END
                              END
                         END
                    END
               END ELSE
                    CELL.TYPE = "E"
                    GOSUB SET.ARRAY.CELL:
               END
          NEXT ROW.NUM
     NEXT COL.NUM

     RETURN


CHECK.LENGTH:
     * CHECK LENGTH
     CELL.LEN=LEN(CELL.VALUE)
     IF CELL.LEN > 0 THEN
          COL.META<COL.NUM,OCCUPIED.QTY.A> += 1
          IF COL.META<COL.NUM,MIN.LEN.A> = 0 THEN COL.META<COL.NUM,MIN.LEN.A> = CELL.LEN
     END ELSE
          COL.META<COL.NUM,EMPTY.QTY.A> += 1
     END
     COL.META<COL.NUM,LEN.TOTAL.A> += CELL.LEN
     LOCATE CELL.LEN IN COL.META<COL.NUM,LENGTHS.A> BY 'AR' SETTING POS THEN
          COL.META<COL.NUM,LENGTHS.QTY.A,POS> += 1
     END ELSE
          INS CELL.LEN BEFORE COL.META<COL.NUM,LENGTHS.A,POS>
          INS '1' BEFORE COL.META<COL.NUM,LENGTHS.QTY.A,POS>
     END
     IF COL.META<COL.NUM,LENGTHS.QTY.A,POS> > COL.META<COL.NUM,LEN.POP.QTY.A> THEN
          COL.META<COL.NUM,LEN.POP.A> = COL.META<COL.NUM,LENGTHS.A,POS>
          COL.META<COL.NUM,LEN.POP.QTY.A> = COL.META<COL.NUM,LENGTHS.QTY.A,POS>
     END
     IF CELL.LEN < COL.META<COL.NUM,MIN.LEN.A> THEN COL.META<COL.NUM,MIN.LEN.A> = CELL.LEN
     IF CELL.LEN > COL.META<COL.NUM,MAX.LEN.A> THEN COL.META<COL.NUM,MAX.LEN.A> = CELL.LEN
     RETURN

SET.ARRAY.CELL:
     LOCATE CELL.TYPE IN COL.META<COL.NUM,CELL.TYPES.A> BY 'AR' SETTING POS THEN
          COL.META<COL.NUM,CELL.TYPES.QTY.A,POS> += 1
     END ELSE
          INS CELL.TYPE BEFORE COL.META<COL.NUM,CELL.TYPES.A,POS>
          INS '1' BEFORE COL.META<COL.NUM,CELL.TYPES.QTY.A,POS>
     END
     IF COL.META<COL.NUM,CELL.TYPES.QTY.A,POS> => COL.META<COL.NUM,PRED.TYPE.QTY.A> THEN
          COL.META<COL.NUM,PRED.TYPE.A> = CELL.TYPE
          COL.META<COL.NUM,PRED.TYPE.QTY.A> = COL.META<COL.NUM,CELL.TYPES.QTY.A,POS>
     END
     RETURN


ANALYZE.NUMERIC.ONLY:
     * THE VALUE OF THE CELL IS STRICTLY NUMERIC
     TRIM.CELL = TRIM(CELL.VALUE," ","A")
     IF INDEX(TRIM.CELL,"-",1) = 0 THEN
          IF NUM(CELL.VALUE) THEN
               GOSUB ANALYZE.CURRENCY:
               IF CELL.TYPE <> "$" THEN
                    CELL.NUM.ONLY = 1
                    CELL.TYPE = "9"
                    GOSUB SET.ARRAY.CELL:
                    COL.META<COL.NUM,NUM.ONLY.A> += 1
                    IF COL.META<COL.NUM,NUM.LOW.A> = "" THEN COL.META<COL.NUM,NUM.LOW.A> = CELL.VALUE
                    IF CELL.VALUE <= COL.META<COL.NUM,NUM.LOW.A> THEN COL.META<COL.NUM,NUM.LOW.A> = CELL.VALUE
                    IF CELL.VALUE >= COL.META<COL.NUM,NUM.HIGH.A> THEN COL.META<COL.NUM,NUM.HIGH.A> = CELL.VALUE
                    COL.META<COL.NUM,NUM.TOTAL.A> += CELL.VALUE
                    COL.META<COL.NUM,NUM.AVG.A> = COL.META<COL.NUM,NUM.TOTAL.A>/ROW.NUM
               END
          END
     END
     RETURN


ANALYZE.ALPHA.ONLY:
     * THIS SUB IS ONLY CALLED IF THE VALUE CONTAINS NON-NUMERIC CHARACTERS
     * WE'LL COLLECT ALL THE NON-NUMERIC CHARACTERS IN EACH COLUMN
     CELL.ALPHA.ONLY = ALPHA(CELL.VALUE)
     IF CELL.ALPHA.ONLY THEN
          COL.META<COL.NUM,ALPHA.A>+=1
          CELL.TYPE = "A"
          GOSUB SET.ARRAY.CELL:
     END
     RETURN


ANALYZE.UOM:

     * HAS NO NUMERIC DIGITS SO...
     * CHECKING IF THE CELL CONTAINS A UNIT OF MEASURE DESCRIPTOR
     IF CELL.TYPE = "A" THEN
          UOM.DONE = 0
          FOR UM.X = 1 TO UM.COUNT
               IF CELL.VALUE = TRIM(UM<UM.X>) THEN
                    COL.META<COL.NUM,UOM.QTY.A>+=1
                    CELL.TYPE = "U"
                    GOSUB SET.ARRAY.CELL:
                    UOM.DONE = 1
               END
          UNTIL UOM.DONE
          NEXT UM.X
     END
     RETURN

ANALYZE.DATE:
     * IF NOT A CURRENCY THEN CHECK FOR A VALID DATE

     CELL.DATE = 0
     FOR DATE.X = 1 TO DF.COUNT
          CELL.DATE = ICONV(CELL.VALUE,DF<DATE.X>)
          IF CELL.DATE > 0 THEN
               *CELL CONTAINS A VALID DATE
               COL.META<COL.NUM,DATE.QTY.A>+=1
               CELL.TYPE = "D"
               COL.META<COL.NUM,DATE.FORMAT.A> = DF<DATE.X>
               GOSUB SET.ARRAY.CELL:
               IF COL.META<COL.NUM,DATE.OLDEST.A> = "" THEN COL.META<COL.NUM,DATE.OLDEST.A> = CELL.DATE
               IF CELL.DATE < COL.META<COL.NUM,DATE.OLDEST.A> THEN COL.META<COL.NUM,DATE.OLDEST.A> = CELL.DATE
               IF CELL.DATE => COL.META<COL.NUM,DATE.NEWEST.A> THEN COL.META<COL.NUM,DATE.NEWEST.A> = CELL.DATE
          END
     UNTIL CELL.DATE > 0
     NEXT DATE.X
     RETURN


ANALYZE.CURRENCY:
     CELL.TRIM = TRIM(CELL.VALUE)
     CONVERT "$-,+" TO "" IN CELL.TRIM
     IF DCOUNT(CELL.TRIM,".") = 2 THEN
          IF ABS(CELL.TRIM) > 0  THEN
               CELL.TYPE = "$"
               COL.META<COL.NUM,CURRENCY.QTY.A>+=1
               IF COL.META<COL.NUM,CURRENCY.LOW.A> = "" THEN COL.META<COL.NUM,CURRENCY.LOW.A> = CELL.TRIM
               GOSUB SET.ARRAY.CELL:
               CELL.CURRENCY.AMT = CELL.TRIM
               COL.META<COL.NUM,CURRENCY.TOTAL.A> += CELL.CURRENCY.AMT
               COL.META<COL.NUM,CURRENCY.AVG.A> = COL.META<COL.NUM,CURRENCY.TOTAL.A> /ROW.NUM
               IF CELL.CURRENCY.AMT < COL.META<COL.NUM,CURRENCY.LOW.A> THEN COL.META<COL.NUM,CURRENCY.LOW.A> = CELL.CURRENCY.AMT
               IF CELL.CURRENCY.AMT > COL.META<COL.NUM,CURRENCY.HIGH.A> THEN COL.META<COL.NUM,CURRENCY.HIGH.A> = CELL.CURRENCY.AMT
          END
     END
     RETURN


ANALYZE.COLUMNS:
     IF LM THEN PRINT "ANALYZE.COLUMNS:"
     COLUMN.NAMES = ""
     COLUMN.LETTERS = ""
     COLUMN.NUMBERS = ""
     COLUMN.TYPES = ""
     GOSUB IDENTIFY.COLUMNS:

     RETURN
     * TYPES OF VALUES IN EACH CELL ARE: $,9,A,E,D,U,S (CURRENCY, NUMBER ONLY, ALPHA ONLY, EMPTY, DATE, UOM, ALPHA NUMERIC STRING)

PARSE.MAP:
     IF LM THEN PRINT "*** PARSE.MAP"

     VENDOR.UP.LABELS=""
     VENDOR.HEAD.LABELS=CHANGE("UPC.FORMAT,DATA.START",",",@VM)
     VENDOR.UP.VALUES =""
     VENDOR.HEAD.VALUES=""

     IF ROW(1)[1,6] = "***LCS" THEN
          IF LM THEN PRINT ROW(1)
          LCS.LINE = CHANGE(ROW(1),",",@FM)
          LCS.LINE = CHANGE(LCS.LINE,CHAR(9),@FM)
          LCS.LINE = CHANGE(LCS.LINE,":",@FM)
          LCS.CT = DCOUNT(LCS.LINE,@FM)

          FOR LABEL.X = 1 TO LCS.CT
               COL.LABEL = LCS.LINE<LABEL.X>
               IF COL.LABEL = "CATNUM" THEN COL.LABEL = "MFR_CAT_NUM"
               IF COL.LABEL = "EFFDATE" THEN COL.LABEL = "PRICE_EFF_DATE"
               IF COL.LABEL = "COST" THEN COL.LABEL = "CUSTOM_PRICE2"
               IF COL.LABEL = "UOM" THEN COL.LABEL = "CUSTOM_PRICE2_UOM"
               READ DBUFF FROM D.I2PS,COL.LABEL THEN
                    IF DBUFF<1> = "D" THEN D.ATT = DBUFF<2> ELSE D.ATT = ""
                    LOCATE COL.LABEL IN VENDOR.UP.LABELS<1> BY 'AL' SETTING POS ELSE
                         INS COL.LABEL BEFORE VENDOR.UP.LABELS<1,POS>
                         INS '' BEFORE VENDOR.UP.VALUES<1,POS>
                    END
                    CV = LCS.LINE<LABEL.X+1>
                    IF LEN(CV) = 1 THEN
                         IF ALPHA(CV) THEN
                              CV= SEQ(CV)-ASCII.ALPHA
                              VENDOR.UP.VALUES<1,POS,1> = CV
                              VENDOR.UP.VALUES<1,POS,2>=D.ATT
                         END
                    END
               END
          NEXT LABEL.X
          FOR LABEL.X = 1 TO DCOUNT(VENDOR.HEAD.LABELS,@VM)
               IF VENDOR.HEAD.LABELS<1,LABEL.X> THEN
                    LOCATE VENDOR.HEAD.LABELS<1,LABEL.X> IN LCS.LINE SETTING POS THEN
                         VENDOR.HEAD.VALUES<1,LABEL.X> = LCS.LINE<POS+1>
                    END
               END
          NEXT LABEL.X
     END
     COL.LABELS = VENDOR.UP.LABELS
     COL.VALUES = VENDOR.UP.VALUES
     HEADER.LABELS = VENDOR.HEAD.LABELS
     HEADER.VALUES = VENDOR.HEAD.VALUES
     RETURN

IDENTIFY.COLUMNS:
     IF LM THEN PRINT "***IDENTIFY.COLUMNS:"
     LOWEST.CURRENCY = 0
     EARLIEST.DATE = ""
     LATEST.DATE = ""
     FOR COL.NUM = 1 TO MAX.COLS
          IF COL.META<COL.NUM,COL.NUM.USED.A> THEN
               COL.NUM.USED = COL.META<COL.NUM,COL.NUM.USED.A>
               COL.TYPE = COL.META<COL.NUM,PRED.TYPE.A>
               COL.LETTER = COL.META<COL.NUM,COL.LETTER.A>
               COL.NAME = COL.META<COL.NUM,NAMES.A>
               MAX.LEN = COL.META<COL.NUM,MAX.LEN.A>
               MIN.LEN = COL.META<COL.NUM,MIN.LEN.A>
               AVG.LEN = COL.META<COL.NUM,LEN.POP.A>
               DATE.OLDEST = COL.META<COL.NUM,DATE.OLDEST.A>
               DATE.NEWEST = COL.META<COL.NUM,DATE.NEWEST.A>

               BEGIN CASE
                    CASE COL.TYPE = '9'
                         IF MAX.LEN = MIN.LEN THEN
                              IF MAX.LEN = 11 THEN
                                   UPC.COL = COL.NUM
                                   COL.NAME = "UPC"
                                   UPC.FORMAT=''
                              END
                              IF MAX.LEN = 12 THEN
                                   UPC.COL = COL.NUM
                                   COL.NAME = "UPC"
                                   UPC.FORMAT = "[1,11]"
                              END
                              IF MAX.LEN = 10 THEN
                                   UPC.COL = COL.NUM
                                   COL.NAME = "UPC"
                                   UPC.FORMAT = "0+"
                              END
                              IF MAX.LEN = 6 THEN
                                   UPC.COL = COL.NUM
                                   COL.NAME = "UPC"
                                   UPC.FORMAT = "VN+"
                              END
                         END

                    CASE COL.TYPE = 'D'
                         EFFDATE = COL.NUM
                         COL.NAME = "EFFDATE"


                    CASE COL.TYPE = '$'
                         CUR.AMT = COL.META<COL.NUM,CURRENCY.AVG.A>
                         IF LOWEST.CURRENCY = 0 THEN LOWEST.CURRENCY = CUR.AMT
                         IF CUR.AMT > 0 AND CUR.AMT <= LOWEST.CURRENCY THEN
                              LOWEST.CURRENCY = CUR.AMT
                              COST.COL = COL.NUM
                              COL.NAME = "COST"
                         END


                    CASE COL.TYPE = 'U'
                         IF NOT(UOM.COL) THEN UOM.COL = COL.NUM
                         COL.NAME = "UOM"
                         UOM.COL = COL.NUM

                    CASE 1
                         IF AVG.LEN > 0 THEN
                              IF AVG.LEN < 30 THEN
                                   IF CAT.COL = "" THEN
                                        CAT.COL = COL.NUM
                                        COL.NAME = "CATNUM"
                                   END
                              END
                         END
               END CASE

               IF COL.NAME THEN
                    COL.META<COL.NUM,NAMES.A> = COL.NAME
                    LOCATE COL.NAME IN VENDOR.UP.LABELS SETTING POS THEN
                         VENDOR.UP.VALUES<POS> = SEQ(COL.LETTER-ASCII.ALPHA)
                    END
               END
               COLUMN.NAMES<COL.NUM.USED> = COL.NAME
               COLUMN.LETTERS<COL.NUM.USED> = COL.LETTER
               COLUMN.NUMBERS<COL.NUM.USED> = COL.NUM
               COLUMN.TYPES<COL.NUM.USED> = COL.TYPE
          END
     NEXT COL.NUM

     RETURN


CHECK.ERRORS:
     IF NOT(UPC.COL) THEN ERRORS<-1> = "NO UPC.COL FOUND.  WILL TRY TO FIND CATALOG NUMBER COLUMN"
     IF NOT(CAT.COL) THEN ERRORS<-1> = "NO CATALOG NUMBER COLUMN WAS FOUND"
     IF NOT(COST.COL) THEN ERRORS<-1> = "NO COST COLUMN WAS FOUND"
     IF NOT(UOM.COL) THEN ERRORS<-1> = "NO UOM COLUMN WAS FOUND.  WILL DEFAULT TO USING EA"
     RETURN
     EQU ESC TO CHAR(27), STX TO CHAR(2), CR TO CHAR(13)
     PRINT ESC:STX:'<':CMD:CR:


     WORD2 = WORD
     NG = "/-',\.#()+[]`~!@$^&*;:=_%"
     CONVERT NG TO "" IN WORD2

     RETURN (WORD2)
     Q = FIELD(@SENTENCE," ",1)
     CRLF = CHAR(13):CHAR(10)
     READV LCS.BPS FROM LCS.CONTROL,'LCS.BPS2',1 THEN
          LC = DCOUNT(LCS.BPS,@VM)
          FOR L = 1 TO LC
               LFILE = LCS.BPS<L>
               PRINT LFILE
               OPEN '',LFILE TO L.FILE THEN
                    LOOP
                    WHILE READNEXT AA DO
                         READ PBUFF FROM L.FILE,AA THEN
                              LCOUNT = DCOUNT(PBUFF,@FM)
                              FOR X = 1 TO LCOUNT
                                   LOCATE Q IN PBUFF<X> THEN
                                        PRINT LFILE:"    ":AA "L#20 <":X:"> ":PBUFF<X>
                                   END
                              NEXT X
                         END
                    REPEAT
                    CLOSE L.FILE
               END
          NEXT L
     END
     STOP
     *SELECT.STR = "SELECT ":LFILE
     *PRINT SELECT.STR:"  ":Q
     *DATA Q,CRLF
     *EXECUTE SELECT.STR CAPTURING CAP
     *PRINT CAP
     *EXECUTE "SAVE-LIST ":LFILE
     *NEXT L
     *FOR L = 1 TO L
     *PRINT L
     *LFILE = LCS.BPS<L>
     *SELECT.STR = "GET-LIST ":LFILE
     *EXECUTE SELECT.STR
     *SELECT.STR = "DIR ":LFILE:" -D"
     *EXECUTE SELECT.STR
     *NEXT L
     *END
     *STOP
     Q = FIELD(@SENTENCE," ",1)
     CRLF = CHAR(13):CHAR(10)
     READV LCS.BPS FROM LCS.CONTROL,'LCS.BPS',1 THEN
          LC = DCOUNT(LCS.BPS,@VM)
          FOR L = 1 TO LC
               PRINT L
               LFILE = LCS.BPS<L>
               SELECT.STR = "SEARCH ":LFILE
               PRINT SELECT.STR:"  ":Q
               DATA Q,CRLF
               EXECUTE SELECT.STR CAPTURING CAP
               PRINT CAP
               EXECUTE "SAVE-LIST ":LFILE
          NEXT L
          FOR L = 1 TO L
               PRINT L
               LFILE = LCS.BPS<L>
               SELECT.STR = "GET-LIST ":LFILE
               EXECUTE SELECT.STR
               SELECT.STR = "DIR ":LFILE:" -D"
               EXECUTE SELECT.STR
          NEXT L
     END
     STOP
     EXECUTE "SSELECT FAX.LOG WITH DATE > ":OCONV(DATE()-3,"D4-")
     *      EXECUTE "SAVE-LIST FAX"
     *      EXECUTE "GET-LIST FAX"
     *      EXECUTE "SSELECT FAX.LOG BY-DSND DATE"
     *      EXECUTE "SELECT FAX.LOG"
     EXECUTE "LIST FAX.LOG BY-DSND DATE"
     EXECUTE "TERM 79"

     EXECUTE "CREATE.FILE USER.INFO 1 101 1 1"
     EXECUTE "CREATE.FILE DOCUMENTS 1 101 1 1"
     EXECUTE "CREATE.FILE MULTIMEDIA.FILES 1 101 1 1"
     EXECUTE "CREATE.FILE FINANCIAL.RECORDS 1 101 1 1"
     EXECUTE "CREATE.FILE SOURCE.CODE 1 101 1 1"
     EXECUTE "CREATE.FILE PASSWORDS 1 101 1 1"


     FILE.NAME = 'USER.INFO'
     DICT.NAME = 'USER.ID'
     TYPE = 'D'
     ATTR.NO = 1
     LENGTH = 7
     DESC = 'User ID'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 10
     GOSUB CREATE.DICTS

     FILE.NAME = 'USER.INFO'
     DICT.NAME = 'FIRST.NAME'
     TYPE = 'D'
     ATTR.NO = 2
     LENGTH = 30
     DESC = 'First Name'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'USER.INFO'
     DICT.NAME = 'LAST.NAME'
     TYPE = 'D'
     ATTR.NO = 3
     LENGTH = 30
     DESC = 'Last Name'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'USER.INFO'
     DICT.NAME = 'EMAIL'
     TYPE = 'D'
     ATTR.NO = 4
     LENGTH = 50
     DESC = 'Email'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'USER.INFO'
     DICT.NAME = 'PASSWORD'
     TYPE = 'D'
     ATTR.NO = 5
     LENGTH = 50
     DESC = 'Password (Encrypted)'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'RECORD.ID'
     TYPE = 'D'
     ATTR.NO = 1
     LENGTH = 7
     DESC = 'Record ID'
     CONV = ''
     FORMAT = 'R'
     S.M.FLAG = 10
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'USER.ID'
     TYPE = 'D'
     ATTR.NO = 2
     LENGTH = 7
     DESC = 'User ID'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'WEBSITE'
     TYPE = 'D'
     ATTR.NO = 3
     LENGTH = 100
     DESC = 'Website/Platform'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'USERNAME'
     TYPE = 'D'
     ATTR.NO = 4
     LENGTH = 50
     DESC = 'Username'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'PASSWORD'
     TYPE = 'D'
     ATTR.NO = 5
     LENGTH = 50
     DESC = 'Password (Encrypted)'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     FILE.NAME = 'PASSWORDS'
     DICT.NAME = 'NOTES'
     TYPE = 'D'
     ATTR.NO = 6
     LENGTH = 200
     DESC = 'Notes'
     CONV = ''
     FORMAT = 'L'
     S.M.FLAG = 1
     GOSUB CREATE.DICTS

     STOP

CREATE.DICTS:
     OPEN 'DICT', FILE.NAME TO DICT.F ELSE STOP 201, FILE.NAME
     FORMAT := LENGTH:FORMAT
     DICT.REC = TYPE : @AM : ATTR.NO : @AM :CONV: @AM : DESC :  @AM : FORMAT
     WRITE DICT.REC ON DICT.F, DICT.NAME
     RETURN
     OPEN 'VEND_ABB' TO VEND_ABB ELSE PRINT 'VEND_ABB';STOP

     INCLUDE FILE.EQU INVENT.EQ
     INCLUDE FILE.EQU VEND_ABB.EQ

     SELECT.STR = 'SSELECT VEND_ABB BY-DSND LEN'


     PRINT SELECT.STR
     EXECUTE SELECT.STR CAPTURING CAP
     PRINT CAP
     READLIST VA.KEYS THEN
          KC =  DCOUNT(VA.KEYS,@FM)
          FOR X = 1 TO KC
               VA.K = VA.KEYS<X>
               READ VA.B FROM VEND_ABB,VA.K THEN
                    IF VA.PG = "" THEN VA.PG = VA.K[1,3]
                    SELECT.STR5 = 'SELECT INVENT WITH DESC1 = ':VA.K:'] AND WITH CATNUM = ""'
                    PRINT SELECT.STR5
                    EXECUTE SELECT.STR5 CAPTURING CAP
                    PRINT CAP
                    READLIST IKEYS THEN
                         INV.K.CT = DCOUNT(IKEYS,@FM)
                         FOR X2 = 1 TO INV.K.CT
                              INV.K = IKEYS<X2>
                              READ INV.B FROM INVENT,INV.K THEN
                                   LV = LEN(VA.K)
                                   LD = LEN(INV.DESC1)
                                   IF VA.SUB THEN
                                        INV.DESC2 = CHANGE(INV.DESC1,VA.K,VA.SUB)
                                        INV.CATNUM = CHANGE(INV.DESC2,VA.PG,"")
                                   END ELSE
                                        INV.VEND_ABB = VA.K
                                        INV.CATNUM = CHANGE(INV.DESC1,VA.K,"")
                                   END
                                   IF VA.PG THEN INV.P_G = VA.PG
                                   INV.UCAT = INV.P_G:INV.CATNUM
                                   INV.UCAT2 = VA.K[1,1]:INV.CATNUM
                                   WRITE VA.B ON VEND_ABB,VA.K
                                   WRITE INV.B ON INVENT,INV.K
                              END
                         NEXT X2
                    END
               END
          NEXT X
     END
     STOP
     OPEN 'PRICE.GROUP' TO PRICE.GROUP ELSE PRINT 'PRICE.GROUP';STOP
     PROMPT ""

     SELECT.STR = "SELECT VEND.ABB WITHOUT PG"
     EXECUTE SELECT.STR CAPTURING CAP
     PRINT SELECT.STR
     PRINT CAP
     READLIST VA.KEYS THEN
          VAC = DCOUNT(VA.KEYS,@FM)
          FOR X = 1 TO VAC
               KEY=VA.KEYS<X>
               READV PG FROM VEND.ABB,KEY,2 ELSE PG = ""
               PRINT @(-1):
               PRINT X:") KEY:":KEY "L#20 ":
               PRINT PG "L#3"
               PRINT
               FIRST = KEY[1,1]
               SELECT.STR2 = 'SELECT PRICE.GROUP = ':FIRST:'] AND WITH MAJOR.GROUP > "" SAVING UNIQUE MAJOR.GROUP'
               *PRINT SELECT.STR2
               EXECUTE SELECT.STR2 CAPTURING CAP
               *PRINT CAP
               READLIST PG.KEYS THEN
                    PGC = DCOUNT(PG.KEYS,@FM)
                    PRINT @(4):
                    FOR Y = 1 TO PGC
                         PRINT Y:") ":PG.KEYS<Y> "L#3 ":
                         IF NOT(MOD(Y,8)) THEN
                              PRINT
                              PRINT @(4):
                         END
                    NEXT Y
                    PRINT
                    PRINT "CHOICE:":
                    INPUT PG,3
                    IF NUM(PG) THEN PG = PG.KEYS<PG>
                    IF PG = "Q" THEN STOP
                    WRITEV PG ON VEND.ABB,KEY,2
                    PRINT KEY:"  ":PG
               END
          NEXT X
     END
     STOP


     JOB.ID = TRIM(FIELD(@SENTENCE," ",2))
     ACTION = TRIM(FIELD(@SENTENCE," ",3))
     COPY.OPT = TRIM(FIELD(@SENTENCE," ",4))
     IF COPY.OPT = "" THEN COPY.OPT = 'N'
     IF JOB.ID = "" THEN
          PRINT "SEND.FAX.FROM.JOB <JOB.ID> [<ACTION> <COPY.OPTION>]"
          STOP
     END

     EQU IN.FILE.NAME TO INARGS<1,1>
     EQU IN.ITEM.NAME TO INARGS<1,2>
     EQU USER TO INARGS<3>
     EQU OUT.FILE.NAME TO INARGS<4,1>
     EQU OUT.ITEM.NAME TO INARGS<4,2>

     EQU SEND.TO.DATA TO INARGS<5>
     EQU SEND.TO.NAME TO INARGS<5,1>,SEND.TO.COMPANY TO INARGS<5,2>,SEND.TO.EMAIL TO INARGS<5,3>
     EQU SEND.TO.FAX TO INARGS<5,4>,SEND.TO.TYPE TO INARGS<5,5>,SEND.TO.REF TO INARGS<5,6>

     EQU SEND.FROM.DATA TO INARGS<6>
     EQU SEND.FROM.USER TO INARGS<6,1>, SEND.FROM.EMAIL TO INARGS<6,2>, SEND.FROM.PHONE TO INARGS<6,3>, SEND.FROM.COMPANY TO INARGS<6,4>
     EQU SEND.FROM.FAX TO INARGS<6,5>, SEND.FROM.PHOTO TO INARGS<6,6>, SEND.FROM.TTILE TO INARGS<6,7>, SEND.FROM.DEPT TO INARGS<6,8>

     EQU MESSAGE.BODY TO INARGS<7>
     EQU COMMENTS TO INARGS<8>
     EQU SUBJECT TO INARGS<9>
     EQU COVERPG TO INARGS<10>
     EQU LASER TO INARGS<11>
     EQU COMMENT TO INARGS<12>
     EQU SENDVIA TO INARGS<13>

     OUTARGS = ""
     LM = 1
     INARGS = ""
     ERRORS = ""
     METHOD = ACTION[2,1]

     INARGS<2> = ACTION
     LFCR = CHAR(10):CHAR(13)

     OPEN 'CONTROL' TO CONTROL ELSE PRINT 'CONTROL' ; STOP
     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL' ; STOP
     OPEN 'LCS.MAIL' TO LCS.MAIL ELSE PRINT 'LCS.MAIL';STOP
     OPEN 'MASTER' TO MASTER ELSE PRINT 'MASTER' ; STOP
     READV DDI.PATH FROM LCS.CONTROL,"DDI.PATH",1 ELSE DDI.PATH = "C:\U2\UV\ACCOUNTS\DDI\"
     READV LCS.PATH FROM LCS.CONTROL,"LCS.PATH",1 ELSE LCS.PATH = "C:\U2\UV\ACCOUNTS\DDI.LCS\"
     READV LOGS.PATH FROM LCS.CONTROL,"LOGS.PATH",1 ELSE LOGS.PATH = "C:\U2\UV\ACCOUNTS\DDI.LOGS\"
     READV HOME.PATH FROM LCS.CONTROL,"HOME.PATH",1 ELSE HOME.PATH = "\\CE1\Folder Redirection\"
     READ COMP.B FROM CONTROL,'COMPANY' ELSE COMP.B = ''
     *
     READV SMTP.SERVER FROM LCS.CONTROL,"SMTP.SERVER",1 ELSE SMTP.SERVER = "CESMX.CES.LOCAL"
     READV FAX.OUT.PATH FROM LCS.CONTROL,"FAX.OUT.PATH",1 ELSE FAX.OUT.PATH = LCS.PATH:"FAXES\OUT\"
     READV PDF.OUT.PATH FROM LCS.CONTROL,"PDF.OUT.PATH",1 ELSE PDF.OUT.PATH = LCS.PATH:"PDF\OUT\"
     READV LOG.FILEPATH FROM LCS.CONTROL,"LOG.FILEPATH",1 ELSE LOG.FILEPATH = LOGS.PATH:"LOGS\"
     !
     BASE = DDI.PATH
     PCL.BASE = "C:\U2\UV\ACCOUNTS\DDI\PW.PCL"
     PDF.BASE = "C:\U2\UV\ACCOUNTS\DDI\CONSERVE.FAX"
     EMAILSERVER = "cesmx.ces.local"
     EMAILSERVER = "smtp.rcn.com"
     PWLOG.NAME = 'C:\PWLOG-':OCONV(DATE(),'D2-'):'.TXT'

     READ COMP.B FROM CONTROL,'COMPANY' ELSE COMP.B = '' ; PRINT 'COMPANY RECORD MISSING' ; STOP
     IN.FILE.NAME = "PW.PCL"
     OUT.FILE.NAME = "CONSERVE.FAX"
     OPEN IN.FILE.NAME TO F.IN.FILE ELSE PRINT IN.FILE.NAME ; STOP
     OPEN OUT.FILE.NAME TO F.OUT.FILE ELSE PRINT OUT.FILE.NAME ; STOP

     OPEN 'FAX.LOG' TO FAX.LOG ELSE PRINT 'FAX.LOG' ; STOP
     OPEN 'FAX.DET' TO FAX.DET ELSE PRINT 'FAX.DET' ; STOP
     SELECT.STR = 'SELECT FAX.LOG WITH JOB.ID = ':JOB.ID
     IF LM THEN PRINT SELECT.STR
     EXECUTE SELECT.STR CAPTURING CAP
     IF LM THEN PRINT CAP
     READLIST AA THEN
          FAX.LOG.ID = AA<1>
          USER=FIELD(AA,"*",1)
          READ FAX.LOG.B FROM FAX.LOG,AA THEN
               GOSUB PARSE.FROM.DATA:
               GOSUB PARSE.TO.DATA:
               GOSUB PARSE.LOG.DATA:
          END ELSE PRINT "FAX.LOG RECORD MISSING ":AA ; STOP
          JOBNO = FIELD(AA,"*",2)
          DOS.SCRIPT.NAME = "MAIL":JOBNO:'.BAT'
          PS.SCRIPT.NAME = "MAIL":JOBNO:".PS1"
          SUBJECT = "(ID:":JOBNO:") ":SUBJECT
          DOS.SCRIPT.BODY = ""
          CONVERT "." TO "" IN SEND.TO.NAME
          NEW.ITEM.NAME = CHANGE(AA,"*","_")
          PCL.ITEM = NEW.ITEM.NAME:".PCL"
          IN.ITEM.NAME = PCL.ITEM
          PCL.NAME = PCL.BASE:"\":PCL.ITEM

          * CREATE PCL FILE
          READ FAX.B FROM FAX.DET,AA THEN
               IF LM THEN PRINT "WRITING PCL FILE ":PCL.ITEM
               WRITE FAX.B ON F.IN.FILE,PCL.ITEM
          END

          *ADD LINE TO BATCH FILE TO CREATE PDF
          PDF.NAME = PDF.BASE:"\":NEW.ITEM.NAME:".PDF"
          PDF.CMD = '"C:\Program Files (x86)\Rasmussen Software, Inc\Print Wizard 4.1\PRINTWIZ.EXE" /PDF ':PCL.NAME:' /Q /LOG=':PWLOG.NAME:' /W /F=':PDF.NAME
          OUT.ITEM.NAME = NEW.ITEM.NAME:".PDF"
          IN.FILE.NAME = "CONSERVE.FAX"
          IF LM THEN PRINT PDF.CMD
          DOS.SCRIPT.BODY<-1> =  PDF.CMD

          *ADD LINE TO EXECUTE POWERSHELL SCRIPT WHCIH WILL DELIVER EMAIL/FAX
          IF (ACTION[1,1] = 'E' ! ACTION[1,1] = "F") THEN
               INARGS<2> = ACTION
               INARGS<15> = JOBNO

               *WRITE BATCH FILE
               WRITE DOS.SCRIPT.BODY ON LCS.MAIL,DOS.SCRIPT.NAME

               CALL SEND.DOC(INARGS,OUTARGS,ERRORS)
               READ DOS.SCRIPT.BODY FROM LCS.MAIL,DOS.SCRIPT.NAME ELSE DOS.SCRIPT.BODY = ''
               IF LM THEN PRINT "READING ":DOS.SCRIPT.NAME
               IF LM THEN PRINT DOS.SCRIPT.BODY
               READV TESTS FROM LCS.MAIL,PS.SCRIPT.NAME,1 THEN
                    DOS.SCRIPT.BODY<-1> = 'POWERSHELL.EXE "& C:\U2\UV\ACCOUNTS\DDI\LCS.MAIL\':PS.SCRIPT.NAME:'"'
               END
          END

          *ADD LINE TO BATCH FILE TO COPY DOCUMENT TO SHAREPOINT SITE
          IF COPY.OPT <> "N" THEN
               GOSUB COPY.PDF:
          END

          *WRITE BATCH FILE
          WRITE DOS.SCRIPT.BODY ON LCS.MAIL,DOS.SCRIPT.NAME

          *SUBMIT BATCH FILE AS JOB FOR IMMEDIATE EXECUTION
          IF DOS.SCRIPT.BODY > "" THEN
               DOS.CMD = 'DOS /C C:\U2\UV\ACCOUNTS\DDI\LCS.MAIL\':DOS.SCRIPT.NAME
               *                        DOS.CMD = 'DOS /C SCHTASKS /CREATE /TN ':DOS.SCRIPT.NAME:' /SC ONCE /ST ':OCONV(TIME()+61,'MT'):' /F /TR ':DOS.CMD
               IF LM THEN PRINT DOS.CMD
               EXECUTE DOS.CMD CAPTURING CAP
               IF LM THEN PRINT CAP
               SLEEP 1
          END

     END


     CLOSE F.IN.FILE
     CLOSE F.OUT.FILE
     PRINT "FINISHED"
     STOP

     *EQU SEND.TO.DATA TO INARGS<5>
     *EQU SEND.TO.NAME TO INARGS<5,1>,SEND.TO.COMPANY TO INARGS<5,2>,SEND.TO.EMAIL TO INARGS<5,3>
     *EQU SEND.TO.FAX TO INARGS<5,4>,SEND.TO.TYPE TO INARGS<5,5>,SEND.TO.REF TO INARGS<5,6>
     *EQU SEND.FROM.DATA TO INARGS<6>
     *EQU SEND.FROM.USER TO INARGS<6,1>, SEND.FROM.EMAIL TO INARGS<6,2>, SEND.FROM.PHONE TO INARGS<6,3>, SEND.FROM.COMPANY TO INARGS<6,4>
     *EQU SEND.FROM.FAX TO INARGS<6,5>, SEND.FROM.PHOTO TO INARGS<6,6>, SEND.FROM.TTILE TO INARGS<6,7>, SEND.FROM.DEPT TO INARGS<6,8>

PARSE.TO.DATA:
     IF NOT(SEND.TO.EMAIL) THEN
          SUBJECT = "*** Error: An request to email was received without a valid 'Email to:' address"
          EMAILBODY = "Please review and resend your message.  No email was sent for this request"
     END
     IF NOT(SEND.TO.NAME) THEN SEND.TO.NAME = SEND.TO.EMAIL
     RETURN

PARSE.FROM.DATA:
     COEMAIL = COMP.B<161>
     IF COEMAIL = '' THEN
          ERRORS = 'Company Email Address is Missing!'
          RETURN
     END
     READ USER.B FROM MASTER, 'SYSTEM.USERS' ELSE USER.B = ''
     LOCATE USER IN USER.B<4> SETTING VM THEN
          USEREMAIL = USER.B<8,VM>
          USERNAME = TRIM(FIELD(USEREMAIL,'@',1))
     END ELSE USEREMAIL = ''
     IF USEREMAIL = '' THEN USEREMAIL = COEMAIL
     SEND.FROM.USER = USERNAME
     SEND.FROM.EMAIL = USEREMAIL
     IF NOT(SEND.FROM.FAX) THEN SEND.FROM.FAX = COMP.B<6>
     RETURN

PARSE.LOG.DATA:
     SENDVIA = FAX.LOG.B<21>
     IF ACTION = "" THEN ACTION = SENDVIA
     SUBJECT = FAX.LOG.B<4>
     FAX.DATE= OCONV(FAX.LOG.B<5>,"D2-")
     FAX.TIME = OCONV(FAX.LOG.B<6>,"MTH")
     IF ACTION[1,1] = 'P' THEN PDF.COPY.NAME = FAX.LOG.B<5,1>
     IF ACTION[1,1] = "E" ! ACTION[1,1] = "F" THEN
          IF SENDVIA = "E" THEN SEND.TO.EMAIL = FAX.LOG.B<1>
          IF SENDVIA = "F" THEN SEND.TO.FAX = FAX.LOG.B<1>
          SEND.TO.NAME = FAX.LOG.B<2>
          SEND.TO.COMPANY = FAX.LOG.B<3>
          SEND.FROM.USER = FAX.LOG.B<14>
          SEND.FROM.COMPANY = FAX.LOG.B<15>
          IF FAX.LOG.B<17> = "Y" THEN COVERPG = "DEFAULT.COV" ELSE COVERPG = FAX.LOG.B<17>
          IF COVERPG ="N" THEN COVERPG = ""
          MESSAGE.BODY = FAX.LOG.B<19>
     END
     LASER = FAX.LOG.B<20>
     RETURN

COPY.PDF:
     GOSUB COPY.PDF.HOME:
     *GOSUB COPY.PDF.USER:
     RETURN



COPY.PDF.HOME:
     TARGET.DIRECTORY = HOME.PATH:USERNAME:'\Documents\_PDF'
     COPY.DOS.CMD = 'COPY ':PDF.NAME:' "':TARGET.DIRECTORY:'" /Y'
     DOS.SCRIPT.BODY<-1> = COPY.DOS.CMD
     RETURN


COPY.PDF.USER:
     TARGET.DIRECTORY = LCS.PATH:'USER_PDF\':USERNAME
     COPY.DOS.CMD = 'COPY ':PDF.NAME:' ':TARGET.DIRECTORY:' /Y'
     EXECUTE 'DOS /C ':COPY.DOS.CMD
     DOS.SCRIPT.BODY<-1> = COPY.DOS.CMD
     RETURN


     OPEN 'TRANS' TO TRANS ELSE PRINT 'TRANS';STOP
     OPEN 'CSV' TO CSV ELSE PRINT 'CSV';STOP
     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL';STOP
     DELETE CSV,FN:'.CSV'
     INCLUDE FILE.EQU TRANS.EQ
     READV NEXT.TRANS.ID FROM LCS.CONTROL,"NEXT.TRANS.ID",1 ELSE NEXT.TRANS.ID = 100001
     READV TRANS.HEAD FROM LCS.CONTROL,"TRANS.HEADER",1 ELSE TRANS.HEAD = ""
     OPENSEQ "LCS.CSV",FN:".CSV" TO TRANS.CSV ELSE CREATE TRANS.CSV ELSE PRINT FN:".CSV";STOP
     SELECT TRANS
     IF TRANS.HEAD THEN
          TRANS.HEAD = CHANGE(TRANS.HEAD,",",@FM)
          WRITESEQ TRANS.HEAD ON TRANS.CSV ELSE PRINT "WRITE FAILURE";STOP
     END
     LOOP
     WHILE READNEXT TR.ID DO
          READ TR.B FROM TRANS,TR.ID THEN
               IF TR.ID = "" THEN TR.ID = NEXT.TRANS.ID
               INS TR.ID BEFORE TR.B<1>
               ODATE = LS.DATE(TR.B<2>)
               MONTH = ODATE[6,2]
               YEAR  = ODATE[1,4]
               DAY = ODATE[9,2]
               TR.B<2> = ODATE
               PERIOD = YEAR:MONTH
               TR.B<8> = OCONV(TR.B<8>,'MD2')
               TR.B<9> = OCONV(TR.B<9>,'MD2')
               TR.B<10> = OCONV(TR.B<10>,'MD2')
               TR.B<20> = MONTH
               TR.B<21> = YEAR
               TR.B<18> = PERIOD
               LINE = CHANGE(TR.B,@FM,CHAR(9))
               WRITESEQ LINE ON TRANS.CSV ELSE PRINT "WRITE FAILURE";STOP
               NEXT.TRANS.ID += 1
          END
     REPEAT
     WRITEV NEXT.TRANS.ID ON LCS.CONTROL,"NEXT.TRANS.ID",1
     PRINT "FINISHED"
     STOP
     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL';STOP
     OPEN 'UPDATE.NAME.XREF' TO UPDATE.NAME.XREF ELSE PRINT 'UPDATE.NAME.XREF';STOP
     OPEN 'TRADESERVICE,NEW' TO TRADE.NEW ELSE PRINT "TRADESERVICE,NEW";STOP
     *update.scope = s,sl,slp (passed as argument)
     *update.class = lod,upd (passed as argument)
     *update.mode = load,refresh,update (based on update class)

     PROMPT ''
     *READV NEXT.TRADE.ISSUE FROM LCS.CONTROL,"NEXT.TRADE.ISSUE",1 ELSE NEXT.TRADE.ISSUE = ""
     READV NEXT.PRICE.UPDATE.LOG FROM LCS.CONTROL,"NEXT.PRICE.UPDATE.LOG",1 ELSE NEXT.PRICE.UPDATE.LOG = ""
     NEXT.TRADE.ISSUE = NEXT.PRICE.UPDATE.LOG<1,1>
     READV TRADE.ACCOUNT FROM LCS.CONTROL,"TRADE.ACCOUNT",1 ELSE TRADE.ACCOUNT = "08527"
     TRUE = 1
     FALSE = 0

     UPDATE.SCOPE = "SLP"
     CMD.LINE = @SENTENCE
     IF GET.OPTION(CMD.LINE,"?") THEN
          PRINT "RUN.TRADE.UPDATES [-LOAD issue#] [-SCOPE scope] [-REFRESH] [-LOGID logid]"
          PRINT
     END ELSE
          UPDATE.MODE = GET.OPTION(CMD.LINE,"REFRESH")
          UPDATE.SCOPE = GET.OPTION(CMD.LINE,"SCOPE")
          LOG.ID = GET.OPTION(CMD.LINE,"LOGID")
          LOAD.ID = GET.OPTION(CMD.LINE,"LOAD")
          IF LOAD.ID THEN
               UPDATE.MODE = 'LOAD'
               UPDATE.ID = LOAD.ID:TRADE.ACCOUNT:"lod"
               IF (UPDATE.ID = "" OR LEN(UPDATE.ID) < 12) THEN
                    PRINT "ENTER UPDATE.ID:":;INPUT UPDATE.ID
               END
               ZIP.FILE = UPDATE.ID:".ZIP"
               READV EXISTS FROM TRADE.NEW,ZIP.FILE,0 ELSE
                    PRINT ZIP.FILE:" NOT FOUND IN TRADESERVICE,NEW"
                    STOP
               END
               ISSUE = UPDATE.ID[1,4]
               IF (NOT(LOG.ID) OR LEN(LOG.ID) < 4 OR NOT(NUM(LOG.ID))) THEN
                    PRINT "ENTER LOG.ID:":;INPUT LOG.ID
               END
               GOSUB PROCESS.UPDATE:
          END ELSE
               UPDATE.CT = 0

               FINISHED = FALSE
               LOOP
                    IF NEXT.TRADE.ISSUE THEN
                         ISSUE = NEXT.TRADE.ISSUE
                         UPDATE.ID = ISSUE:TRADE.ACCOUNT:"upd"
                    END
                    IF NEXT.TRADE.ISSUE THEN
                         LOG.ID = "T":NEXT.TRADE.ISSUE
                    END
                    GOSUB PROCESS.UPDATE:

               UNTIL FINISHED REPEAT
               GOSUB PRINT.FINAL.INFO:
          END
     END
     STOP

PROCESS.UPDATE:
     READ UPNX FROM UPDATE.NAME.XREF, UPDATE.ID ELSE
          UPNX = ""
          UPNX<1> = LOG.ID
     END
     INS UPDATE.MODE BEFORE UPNX<2,1>
     INS UPDATE.SCOPE BEFORE UPNX<3,1>
     INS "STARTED" BEFORE UPNX<4,1>
     INS DATE() BEFORE UPNX<5,1>
     INS TIME() BEFORE UPNX<6,1>
     WRITE UPNX ON UPDATE.NAME.XREF,UPDATE.ID
     OUTARGS = ""
     UPDATE.OPTIONS=UPDATE.MODE
     UPDATE.OPTIONS<2> = UPDATE.SCOPE
     CALL PROCESS.PRICE.UPDATE(UPDATE.ID,UPDATE.OPTIONS,OUTARGS)
     IF OUTARGS THEN
          MESSAGE = OUTARGS<1>
          ERRORS = OUTARGS<2>
          FINISHED = TRUE
     END ELSE
          UPDATES.CT +=1
     END
     RETURN


PRINT.FINAL.INFO:
     PRINT
     PRINT ERRORS:" ERRORS WERE FOUND."
     PRINT UPDATES.CT:" UPDATES WERE SUCCESSFULLY PROCESSED"
     OUTARGS = UPDATES.CT
     PRINT
     RETURN



     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL' ; STOP
     OPEN 'RULES' TO RULES ELSE PRINT 'RULES' ; STOP
     READ RULE.NUM FROM LCS.CONTROL,"RULE.NUM" ELSE RULE.NUM = "1000"
     EXECUTE IMPORT.RULES
     EXECUTE IMPORT.TRANS
     EXECUTE IMPORT.ACCTS
     PROMPT ''
     LM = 1
     FINISHED = @FALSE
     SELECT.STR = "SSELECT RULES"
     IF LM THEN PRINT SELECT.STR
     EXECUTE SELECT.STR CAPTURING CAP
     IF LM THEN PRINT CAP
     READLIST RULE.IDS THEN
          RULE.CT = DCOUNT(RULE.IDS,@FM)
          FOR RULE.X = 1 TO RULE.CT
               RULE.ID = RULE.IDS<RULE.X>
               IF LM THEN PRINT "EXECUTING RULE :":RULE.ID
               CALL RUN.RULE(RULES,TRANS,RULE.ID)
          NEXT RULE.X
     END
     PRINT "EXECUTED ":RULE.CT:" RULES"
     STOP
     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL' ; STOP
     OPEN 'RULES' TO RULES ELSE PRINT 'RULES' ; STOP
     READ RULE.NUM FROM LCS.CONTROL,"RULE.NUM" ELSE RULE.NUM = "1000"
     EXECUTE IMPORT.RULES
     EXECUTE IMPORT.TRANS
     EXECUTE IMPORT.ACCTS
     PROMPT ''
     LM = 1
     FINISHED = @FALSE
     SELECT.STR = "SSELECT RULES"
     IF LM THEN PRINT SELECT.STR
     EXECUTE SELECT.STR CAPTURING CAP
     IF LM THEN PRINT CAP
     READLIST RULE.IDS THEN
          RULE.CT = DCOUNT(RULE.IDS,@FM)
          FOR RULE.X = 1 TO RULE.CT
               RULE.ID = RULE.IDS<RULE.X>
               IF LM THEN PRINT "EXECUTING RULE :":RULE.ID
               CALL RUN.RULE(RULES,TRANS,RULE.ID)
          NEXT RULE.X
     END
     PRINT "EXECUTED ":RULE.CT:" RULES"
     STOP
     OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL' ; STOP
     OPEN 'RULES' TO RULES ELSE PRINT 'RULES' ; STOP
     READ RULE.NUM FROM LCS.CONTROL,"RULE.NUM" ELSE RULE.NUM = "1000"
     RULE.ID = FIELD(@SENTENCE," ",2)
     RULE.CT = 0
     IF RULE.ID THEN
          GOSUB RUN.RULE:
     END ELSE
          EXECUTE "IMPORT.ACCT"
          PROMPT ''
          LM = 1
          FINISHED = @FALSE
          SELECT.STR = "SSELECT RULES"
          IF LM THEN PRINT SELECT.STR
          EXECUTE SELECT.STR CAPTURING CAP
          IF LM THEN PRINT CAP
          READLIST RULE.IDS THEN
               RULE.CT1 = DCOUNT(RULE.IDS,@FM)
               FOR RULE.X = 1 TO RULE.CT1
                    RULE.ID = RULE.IDS<RULE.X>
                    GOSUB RUN.RULE:
               NEXT RULE.X
          END
     END
     PRINT "EXECUTED ":RULE.CT:" RULES"
     STOP

RUN.RULE:
     IF LM THEN PRINT "EXECUTING RULE :":RULE.ID
     CALL RUN.RULE(RULES,TRANS,RULE.ID)
     RULE.CT += 1
     RETURN
     LM=1
     EQU RULE.NAME TO RULE.B<1>, KEYWORD TO RULE.B<2>, PAYEE.NAME TO RULE.B<3>, ACCOUNT.ID TO RULE.B<4>
     EQU CAT.NAME TO RULE.B<4>, CLASS.NAME TO RULE.B<5>, DEPT TO RULE.B<6>, TR.IDS TO RULE.B<7>

     INCLUDE FILE.EQU TRANS.EQ

     IF RULE.ID THEN
          READ RULE.B FROM RULES,RULE.ID ELSE RULE.B = ""
     END

MAIN:
     SELECT.STR =  'SELECT TRANS WITHOUT CATEGORY AND WITH DESC = "[':KEYWORD:']"'
     PRINT SELECT.STR
     EXECUTE SELECT.STR
     READLIST TR.LIST THEN
          LIST.CT = DCOUNT(TR.LIST,@FM)
          IF LIST.CT > 20 THEN
               INPUT ANS,1
               IF ANS = 'Q' THEN STOP
               IF ANS = 'D' THEN DEBUG
          END
          FOR LIST.X = 1 TO LIST.CT
               TR.ID = TR.LIST<LIST.X>
               READ TR.B FROM TRANS,TR.ID THEN
                    TR.PAYEE = PAYEE.NAME
                    TR.CATEGORY = CAT.NAME
                    TR.CLASS = CLASS.NAME
                    TR.DEPT = DEPT
                    TR.RULE = RULE.ID
                    WRITE TR.B ON TRANS,TR.ID
                    IF LM THEN PRINT "APPLYING RULE ":RULE.ID:" TO TRANS ":TR.ID:" ":TR.DESC
               END
          NEXT LIST.X
     END
     RETURN


     LM=1


MAIN:
     RULE.EXP = TRIM(UPCASE(RULE.EXP))
     RULE.B = ""
     RULE.B<1> = FIELD(RULE.EXP,";",1)
     RULE.B<2> = FIELD(RULE.EXP,";",2)
     CRITERIA = RULE.B<1>
     ACTION = RULE.B<2>
     WRITE RULE.B ON RULES,RULE.ID
     GOSUB PARSE.CRITERIA:
     IF TRANS.LIST THEN GOSUB APPLY.ACTION:
     RETURN

APPLY.ACTION:
     ACTION = CHANGE(ACTION,":",@FM)
     IF ACTION = "N" THEN ATT.NUM = 6
     IF ACTION = "C" THEN ATT.NUM = 13
     ATT = ACTION<1>
     VALUE = ACTION<2>
     LIST.CT = DCOUNT(TRANS.LIST,@FM)
     FOR LIST.X = 1 TO LIST.CT
          TRANS.ID = TRANS.LIST<LIST.X>
          READ TRANS.B FROM TRANS,TRANS.ID THEN
               TRANS.B<ATT.NUM> = VALUE
               WRITE TRANS.B ON TRANS,TRANS.ID
          END
     NEXT LIST.X
     RETURN

PARSE.CRITERIA:
     IF DCOUNT(CRITERIA,"&") > 1 THEN
          CRIT1 = FIELD(CRITERIA,"&",1)
          CRIT2 = FIELD(CRITERIA,"&",2)
          CRIT.JOIN = "&"
     END ELSE
          IF DCOUNT(CRITERIA,"|") > 1 THEN
               CRIT1 = FIELD(CRITERIA,"|",1)
               CRIT2 = FIELD(CRITERIA,"|",2)
               CRIT.JOIN = "|"
          END ELSE
               CRIT2 = ""
               CRIT.JOIN = ""
          END
     END
     CRIT = CRIT1
     GOSUB EXPAND.CRIT:
     GOSUB SELECT.CRIT:
     IF SEL.CT THEN
          IF CRIT2 THEN
               EXECUTE "SAVE-LIST 3"
               CRIT = CRIT2
               GOSUB EXPAND.CRIT:
               GOSUB SELECT.CRIT:
               IF SEL.CT THEN
                    EXECUTE "SAVE-LIST 4"
                    IF CRIT.JOIN = "&" THEN
                         EXECUTE "MERGE.LIST 3 INTERSECTION 4" CAPTURING CAP
                    END ELSE
                         EXECUTE "MERGE.LIST 3 UNION 4" CAPTURING CAP
                    END
               END
          END
          LIST.CT = CAP<1,2>
          IF LIST.CT THEN READLIST TRANS.LIST ELSE TRANS.LIST = ""
     END ELSE TRANS.LIST = ""
     RETURN

EXPAND.CRIT:
     BASE = FIELD(CRIT,"=",1)
     IF BASE = "D" THEN BASE = "TR.DESC"
     IF BASE = "T" THEN BASE = "TR.TYPE"
     IF BASE = "C" THEN BASE = "CLASS"
     IF BASE = "N" THEN BASE = "NAME"
     TESTS = FIELD(CRIT,"=",2)
     TEST.CT = DCOUNT(TESTS,@FM)
     TESTS = CHANGE(TESTS,",","] OR !")
     TESTS = CHANGE(TESTS,"+","] AND !")
     TESTS = CHANGE(TESTS,"!",@FM)
     FOR TEST.X = 1 TO TEST.CT
          TEST.EXP := BASE:"=[":TESTS<TEST.X>
     NEXT TEST.X
     TEST.EXP := "]"
     TEST.EXP = "SELECT TRANS WITH ":TRIM(TEST.EXP)
     RETURN

SELECT.CRIT:
     IF LM THEN PRINT TEST.EXP
     EXECUTE TEST.EXP CAPTURING CAP
     SEL.CT = CAP<1,2>
     RETURN


     EQU TR.DESC TO TRANS.B<5>, TR.TYPE TO TRANS.B<2>, TR.NAME TO TRANS.B<6>
     EQU RULE.CRIT TO RULE.B<1>, RULE.ACTION TO RULE.B<2>


     MAJ.DELIM.OR ="|"
     MAJ.DELIM.AND = "&"

     RULE.CRITERIA = RULE.B<1>
     RULE.ACTION =  RULE.B<2>
     IF INDEX(RULE.CRITERIA,"&",1) OR INDEX(RULE.CRITERIA,"|",1)

     CRIT.CT = DCOUNT(RULE.CRITERIA,@VM)
     DCOUNT(
     FOR CRIT.X = 1 TO CRIT.CT
          CRIT = CHANGE(RULE.CRITERIA<CRIT.X>,"ATT.SET")
          SELECT.STR = "SELECT TRANS WITH "
          RULE.DATA = RULE.B<3>
          IF RULE.TYPE = "N" THEN SET.ATT = 6
          IF RULE.TYPE = "C" THEN SET.ATT = 13
          RULE.CRIT1 = FIELD(RULE.CRITERIA,":",1)
          RULE.CRIT2 = FIELD(RULE.CRITERIA,":",2)
          SELECT.STR = "SELECT TRANS WITH CLASS = '' AND WITH "
          IF RULE.CRIT2 = "N" THEN SEL.STR2 = "TR.NAME"
          IF RULE.CRIT2 = "K" THEN SEL.STR2 = "TR.KEY"
          IF RULE.CRIT2 = "C" THEN SEL.STR2 = "TR.CLASS"
          IF RULE.CRIT2 = "T" THEN SEL.STR2 = "TR.TYPE"
          SELECT.STR := SEL.STR2
          SELECT.STR := ' = ':SEL.STR2 = RULE.CR


          t=a,b  k=a+b n=a,b &            &/| n=a,/+b,+/,c

          if((keyword="taxi" or keyword = "cab") or name="uber") then class = "transportation"
          k=taxi,cab|n=uber;c:transportation
          K=rite+aid;N:Rite Aid
          k=walgreen;n:walgreens;
          n=rite aid,cvs,duane reade,walgreens; c:office supplies
n:        k=cvs;n:cvs
n:        k=american+express;n:American Express
          k=gristedes; n:Gristedes c:Groceries
          k=uber;n:Uber
c:        n=uber|K=taxi;c:Transportation;
t:        k=ATM;n=ATM withdrawl c:Petty cash


rulein:
          parse criteria into rule<1>
          parse actions into rule<2>

          bases="c/class,t/trans,n/name,k/keyword"
          operands=",+-^~";* or and not in not-in



ruleout:
          get criteria
          count "="
          for each = get sub.criteria
               sc = field(criteria,",",sc.x)
               base = field(sc,"=",1)
               test.value = field(sc,"=",2)


               set valid = 0
               for each = subcriteria
                    left side of = is base
                    right side are tests


                    if base = "c" then base.value = trans.class
                    if base = "n" then base.value = trans.name
                    if base = 't" then base.value = trans.type


                    result = false
                    begin case
                         case op = "~"
                              if index(base,test.value,1) then result true
                         case op = "^"
                              if index(base,test.value,1) = 0 then true
                         case op = "="
                              if base = test.value then result = true
                         case op = "#"
                              if base <> test.value then result = true
                    end case

                    expression = change(expression,","," OR ")
                    expression = change(expression,"+"," AND ")

                    if base.value = test.value then valid = 1
                    LM=1
                    EQU  KEYWORD TO RULE.B<1>, PAYEE.NAME TO RULE.B<2>, ACCOUNT.ID TO RULE.B<3>
                    EQU  CLASS.NAME TO RULE.B<4>, DEPT TO RULE.B<5>, TR.IDS TO RULE.B<6>
                    OPEN 'ACCOUNTS' TO ACCOUNTS ELSE PRINT 'ACCOUNTS';STOP
                    INCLUDE FILE.EQU TRANS.EQ

                    IF RULE.ID THEN
                         READ RULE.B FROM RULES,RULE.ID ELSE RULE.B = ""
                         READV ACCOUNT.NAME FROM ACCOUNTS,ACCOUNT.ID,1 ELSE ACCOUNT.NAME = ""
                    END

MAIN:

                    KEYWORD = TRIM(KEYWORD)
                    IF LEN(KEYWORD) > 2 THEN

                         SELECT.STR = 'SELECT TRANS WITH NAME_DESC LIKE "...':UPCASE(KEYWORD):'..." AND WITHOUT RULE'
                         PRINT SELECT.STR
                         EXECUTE SELECT.STR CAPTURING CAP
                         LIST.QTY = FIELD(CAP<2>," ",1)
                         PRINT LIST.QTY:" FOUND"
                         READLIST TR.LIST THEN
                              LIST.CT = DCOUNT(TR.LIST,@FM)
                              FOR LIST.X = 1 TO LIST.CT
                                   TR.ID = TR.LIST<LIST.X>
                                   READ TR.B FROM TRANS,TR.ID THEN
                                        TR.PAYEE = PAYEE.NAME
                                        TR.ACCOUNT.ID = ACCOUNT.ID
                                        TR.ACCOUNT.NAME = ACCOUNT.NAME
                                        TR.CLASS = CLASS.NAME
                                        TR.DEPT = DEPT
                                        TR.RULE = RULE.ID
                                        WRITE TR.B ON TRANS,TR.ID
                                        IF LM THEN PRINT "APPLYING RULE ":RULE.ID:" TO TRANS ":TR.ID:" ":TR.DESC
                                   END
                              NEXT LIST.X
                         END
                    END

                    RETURN




