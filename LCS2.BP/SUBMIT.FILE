      *---> Recovered document:
      *---> Recovered document: SUBMIT.FILE
      SUBROUTINE GET.PRICE.SOURCE.PARAMETERS(XMISC,ERRORS)

      *$OPTIONS DEFAULT STATIC.DIM

      ERRORS = ""
      OUTARGS = ""
      LM=1
      IF LM THEN PRINT "*** STARTING SUBMIT.FILE ":XMISC
      **I2.PRICE.UPDATE.LOG
      EQU  UPDATE.TYPE TO XMISC<1>, UPDATEID TO XMISC<2>, USER TO XMISC<3>, UPDATE.NUM TO XMISC<4>
      EQU UPDATE.CODE TO XMISC<5>,  UPDATE.NAME TO XMISC<6>
      EQU NOTE TO XMISC<7>, MAST.EFFDATE TO XMISC<8>, MAST.EXPDATE TO XMISC<9>, UPDATE.MODE TO XMISC<10>
      EQU UPDATE.SCOPE TO XMISC<11>
      EQU FILE.NAME TO XMISC<12,1>, FILE.PATH TO XMISC<12,2>, ITEM.NAME TO XMISC<13>
      EQU DELIM TO XMISC<14>
      EQU COL.LABELS TO XMISC<15>, COL.VALUES TO XMISC<16>
      EQU UPC.COL TO XMISC<16,1>, CAT.COL TO XMISC<16,2>, EFFDATE.COL TO XMISC<16,3>,COST.COL TO XMISC<16,4>, UOM.COL TO XMISC<16,5>
      EQU HEADER.LABELS TO XMISC<17>, HEADER.VALUES TO XMISC<18>
      EQU UPC.FORMAT TO XMISC<18,1>, DATA.START TO XMISC<18,2>
      EQU CUSTOM.SUB TO XMISC<19>
      EQU MAST.UOM TO XMISC<20>
      EQU RUN.COUNT TO XMISC<21>
      EQU V.NUM TO XMISC<22>, V.NAME TO XMISC<23>, V.NEW TO XMISC<24>
      EQU V.UPDATE TO XMISC<25>, V.DELETE TO XMISC<26>, V.ZAP TO XMISC<27>
      EQU V.TOTAL TO XMISC<28>
      EQU T.NEW TO XMISC<29>, T.UPDATE TO XMISC<30>, T.DELETE TO XMISC<31>
      EQU T.ZAPPED TO XMISC<32>, T.TOTAL TO XMISC<33>


      COL.LAB=""
      COL.LAB<1>='COL.LETTER'       :@VM:'CORRESPONDING LETTER ON A SPREADSHEET FOR THE COL'
      COL.LAB<2>='COL.NUMBER'      :@VM:'ORDINAL POSITION OF NON EMPTY COLUMN ON SPREADSHEET'
      COL.LAB<3>='COL.NUM.USED'    :@VM:'ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS'
      COL.LAB<4>='NAMES'            :@VM:'UPC, COST, UOM, C1.COST, EFFDATE'
      COL.LAB<5>='CURRENCY.QTY'     :@VM:'QTY OF VALUES CONSISTENT WITH CURRENCY'
      COL.LAB<6>='CURRENCY.LOW'     :@VM:'LOWEST VALUE IN COLUMN THAT IS  CURRENCY'
      COL.LAB<7>='CURRENCY.HIGH'    :@VM:'HIGHEST VALUE IN COLUMN THAT IS CURRENCY'
      COL.LAB<8>='CURRENCY.TOTAL'   :@VM:'SUM OF ALL CURRENCY VALUES IN COLUMN'
      COL.LAB<9>='CURRENCY.AVG'     :@VM:'AVERAGE OF CURRENCY VALUES FOUND IN COLUMN'
      COL.LAB<10>='UOM.QTY'          :@VM:'QTY OF VALUES CONSISTENT WITH UOM'
      COL.LAB<11>='LENGTHS'         :@VM:'ARRAY OF LENGTHS FOUND IN COLUMN'
      COL.LAB<12>='LENGTHS.QTY'     :@VM:'QTY OF ROWS WITH LENGTHS'
      COL.LAB<13>='MIN.LEN'         :@VM:'MIN LENGTH OF VALUE FOUND IN COLUMN'
      COL.LAB<14>='MAX.LEN'          :@VM:'MAX LENGTH OF VALUE FOUND IN COLUMN'
      COL.LAB<15>='LEN.POP'         :@VM:'MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH'
      COL.LAB<16>='LEN.POP.QTY'     :@VM:'NUM OF ROWS WITH MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH'
      COL.LAB<17>='LEN.TOTAL'       :@VM:'TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
      COL.LAB<18>='ALPHA'           :@VM:'QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC'
      COL.LAB<19>='DATE.OLDEST'     :@VM:'OLDEST DATE VALUE FOUND IN COLUMN'
      COL.LAB<20>='DATE.NEWEST'     :@VM:'NEWEST DATE VALUE FOUND IN COLUMN'
      COL.LAB<21>='DATE.QTY'        :@VM:'QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE'
      COL.LAB<22>='DATE.FORMAT'     :@VM:'FORMAT OF THE DATES FOUND IN THE DATA'
      COL.LAB<23>='NUM.ONLY'        :@VM:'QTY OF VALUES THAT ARE PURE NUMBERS'
      COL.LAB<24>='NUM.HIGH'        :@VM:'HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER'
      COL.LAB<25>='NUM.LOW'         :@VM:'LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER'
      COL.LAB<26>='NUM.TOTAL'       :@VM:'SUM OF VALUES THAT ARE NUM ONLY IN COLUMN'
      COL.LAB<27>='NUM.AVG'         :@VM:'AVG OF VALUES THAT ARE NUM ONLY IN COLUMN'
      COL.LAB<28>='EMPTY.QTY'       :@VM:'QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN'
      COL.LAB<29>='OCCUPIED.QTY'    :@VM:'QTY OF VALUES THAT ARE NOT EMPTY'
      COL.LAB<30>='CELL.DATA'       :@VM:'ARRAY OF VALUES IN COLUMN'
      COL.LAB<31>='PRED.TYPE.QTY'   :@VM:'QTY OF ROWS WITH PREDOMINANT CELL TYPE'
      COL.LAB<32>='CELL.TYPES'   :@VM:'ARRAY OF CELL TYPES FOUND IN COLUMN'
      COL.LAB<33>='CELL.TYPES.QTY'  :@VM:'ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE'
      COL.LAB<34>='PRED.TYPE'       :@VM:'PREDOMINANT TYPE OF VALUE IN THE COLUMN.  TYPES OF VALUES IN EACH CELL ARE: $,9,A,0,D,U,S,#,C (CURRENCY, NUMBER ONLY, ALPHA ONLY, EMPTY, DATE, UOM, ALPHA NUMERIC STRING, UPC, CAT.COL)'

      EQU COL.LETTER.A TO 1          ;* CORRESPONDING LETTER ON A SPREADSHEET FOR THE COL
      EQU COL.NUMBER.A TO 2          ;* ORDINAL POSITION OF NON EMPTY COLUMN ON SPREADSHEET
      EQU COL.NUM.USED.A TO 3          ;* ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS
      EQU NAMES.A TO 4               ;* UPC, COST, UOM, C1.COST, EFFDATE
      EQU CURRENCY.QTY.A TO 5          ;* QTY OF VALUES CONSISTENT WITH CURRENCY
      EQU CURRENCY.LOW.A TO 6          ;* LOWEST VALUE IN COLUMN THAT IS  CURRENCY
      EQU CURRENCY.HIGH.A TO 7      ;* HIGHEST VALUE IN COLUMN THAT IS CURRENCY
      EQU CURRENCY.TOTAL.A TO 8     ;* SUM OF ALL CURRENCY VALUES IN COLUMN
      EQU CURRENCY.AVG.A TO 9          ;* AVERAGE OF CURRENCY VALUES FOUND IN COLUMN
      EQU UOM.QTY.A TO 10           ;* QTY OF VALUES CONSISTENT WITH UOM
      EQU LENGTHS.A TO 11           ;* ARRAY OF LENGTHS FOUND IN COLUMN
      EQU LENGTHS.QTY.A TO 12           ;* QTY OF ROWS WITH LENGTHS
      EQU MIN.LEN.A TO 13           ;* MIN LENGTH OF VALUE FOUND IN COLUMN
      EQU MAX.LEN.A TO 14           ;* MAX LENGTH OF VALUE FOUND IN COLUMN
      EQU LEN.POP.A TO 15           ;* MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH
      EQU LEN.POP.QTY.A TO 16           ;* NUM OF ROWS WITH MOST POPULAR LENGTH FOUND IN COLUMN, QTY OF VALUES THAT ARE OF THAT SPECIFIC LENGTH
      EQU LEN.TOTAL.A TO 17           ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS
      EQU ALPHA.A TO 18                ;* QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC
      EQU DATE.OLDEST.A TO 19           ;* OLDEST DATE VALUE FOUND IN COLUMN
      EQU DATE.NEWEST.A TO 20           ;* NEWEST DATE VALUE FOUND IN COLUMN
      EQU DATE.QTY.A TO 21           ;* QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE
      EQU DATE.FORMAT.A TO 22           ;* FORMAT OF THE DATES FOUND IN THE DATA
      EQU NUM.ONLY.A TO 23           ;* QTY OF VALUES THAT ARE PURE NUMBERS
      EQU NUM.HIGH.A TO 24           ;* HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER
      EQU NUM.LOW.A TO 25           ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
      EQU NUM.TOTAL.A TO 26           ;* SUM OF VALUES THAT ARE NUM ONLY IN COLUMN
      EQU NUM.AVG.A TO 27           ;* AVG OF VALUES THAT ARE NUM ONLY IN COLUMN
      EQU EMPTY.QTY.A TO 28           ;* QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN
      EQU OCCUPIED.QTY.A TO 29      ;* QTY OF VALUES THAT ARE NOT EMPTY
      EQU CELL.DATA.A TO 30           ;* ARRAY OF VALUES IN COLUMN
      EQU PRED.TYPE.QTY.A TO 31      ;* QTY OF ROWS WITH PREDOMINANT CELL TYPE
      EQU CELL.TYPES.A TO 32           ;* ARRAY OF CELL TYPES FOUND IN COLUMN
      EQU CELL.TYPES.QTY.A TO 33      ;* ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE
      EQU PRED.TYPE.A TO 34           ;* PREDOMINANT TYPE OF VALUE IN THE COLUMN.  TYPES OF VALUES IN EACH CELL ARE

      OPEN 'LCS.CONTROL' TO LCS.CONTROL ELSE PRINT 'LCS.CONTROL';STOP
      OPEN 'CONTROL' TO F.CONTROL ELSE PRINT 'CONTROL';STOP
      OPEN 'DICT','I2.PRODUCT.SOURCE' TO D.I2PS ELSE PRINT 'DICT I2.PRODUCT.SOURCE';STOP

      READV I2.PATH FROM LCS.CONTROL,"I2.PATH",1 ELSE I2.PATH = "E:\DATA_ACCOUNTS\PRICE\"
      PRICE.SOURCE.NAME = ITEM.NAME


      IF NOT(ERRORS) THEN
         GOSUB INITIALIZE:
         GOSUB GET.SAMPLE.ROWS:
         GOSUB GET.FIELD.DELIMETER.AND.COLS:
         GOSUB ANALYZE.HEADING:
         GOSUB INITIALIZE.COL.METADATA:
         GOSUB ANALYZE.SAMPLE.CELLS:
         GOSUB ANALYZE.VENDOR:
         GOSUB ANALYZE.COLUMNS:
         GOSUB PARSE.MAP:
         GOSUB CHECK.ERRORS:
      END

      IF LM THEN PRINT "*** FINISHING SUBMIT.FILE ":XMISC


      RETURN

INITIALIZE:
      IF LM THEN PRINT "*** INITIALIZE"
      FALSE = 0
      TRUE = 1
      EOF = FALSE
      MAX.ROWS = 80
      MAX.COLS = 0
      ASCII.ALPHA = 64
      DATES.LIST = ""
      PROVIDED.MAP = TRUE


      DELIMETER = ""


      *FIELD DELIMETERS (POSSIBLE) THAT WE TEST OUR FILE FOR
      DELIMETER.P = ""
      DELIMETER.P<1> = CHAR(9);DELIMETER.P<1,2>="TAB"
      DELIMETER.P<2> = ",";DELIMETER.P<2,2>="COMMA"
      DELIMETER.P<4> = ":";DELIMETER.P<4,2>="COLON"
      DELIMETER.P.COUNT = DCOUNT(DELIMETER.P,@FM)
      *
      **POSSIBLE DATE FORMATS TO TEST FOR
      DF = ""
      DF<1> = "D2/"
      DF<2> = "D4/"
      DF<3> = "DI"
      DF<4> = "D2-"
      DF<5> = "D"
      DF<6> = "D2"
      DF<7> = "D/E"
      DF.COUNT = DCOUNT(DF,@FM)

      * POSSIBLE UNITS OF MEASURE
      UM = ""
      UM<1> = "EA"
      UM<2> = "E"
      UM<3> = "C"
      UM<4> = "M"
      UM<5> = "HU"
      UM<6> = "FT"
      UM<7> = "TH"
      UM<8> = "DZ"
      UM.COUNT = DCOUNT(UM,@FM)

      * POSSIBLE COLUMN TYPES
      CT = "$,9,A,0,D,U,S,#,C"
      CT = CHANGE(CT," ",CHAR(254))
      CT.COUNT = DCOUNT(CT,CHAR(254))


      * POSSIBLE VENDORS
      VEND.NUMS = ""
      UPDATE.NAMES = ""
      UPDATE.CODES = ""
      OPEN 'TS.VEND' TO TS.VEND ELSE PRINT 'TS.VEND';STOP
      SELECT TS.VEND
      READLIST VENDOR.NUMS ELSE ERRORS<-1> = "NO VENDORS FOUND IN TS.VEND"
      IF NOT(ERRORS) THEN
         VEND.COUNT = DCOUNT(VENDOR.NUMS,@FM)
         FOR VEND.X = 1 TO VEND.COUNT
            VEND.NUM = VENDOR.NUMS<VEND.X>
            READ VEND.B FROM TS.VEND,VEND.NUM THEN
               UPDATE.NAMES<-1> = VEND.B<1>
               UPDATE.CODES<-1> = VEND.B<2>
            END
         NEXT VEND.X
      END
      *
      ***INITIALIZE RETURNING VARIABLES
      *UPDATE.CODE = ""
      *VEND.NUMBER = ""
      *UPDATE.NAME = ""
      *USER.NAME = ""
      MAST.UOM1 = ""
      *MAST.EFFDATE = ""
      *MAST.EXPDATE = ""
      *NOTE = ""
      *UPC.COL = ""
      *UPC.FORMAT = ""
      *CAT.COL = ""
      *EFFDATE.COL = ""
      *EXPDATE.COL = ""
      *COST.COL = ""
      *C1.COST.COL = ""
      MAX.COLS = ""
      *DELIM = ""
      *UOM.COL = ""
      *DATA.START = 0

      RETURN


GET.SAMPLE.ROWS:
      IF LM THEN PRINT "***GET.SAMPLE.ROWS"
      DIM ROW(MAX.ROWS)
      IF FILE.PATH THEN
         PRICE.SOURCE.PATH = FILE.PATH:PRICE.SOURCE.NAME
         IF LM THEN PRINT "OPENING ":PRICE.SOURCE.NAME:" TO "
         OPENSEQ PRICE.SOURCE.PATH TO PRICE.FILE ELSE PRINT "UNABLE TO OPEN FILE ":PRICE.SOURCE.PATH;STOP
      END ELSE
         IF (FILE.NAME AND ITEM.NAME) THEN
            OPENSEQ FILE.NAME,ITEM.NAME TO PRICE.FILE ELSE PRINT 'UNABLE TO OPEN ITEM ':ITEM.NAME:' IN FILE ':FILE.NAME;STOP
         END ELSE ERRORS<-1> = 'SOURCE DATA FILE NOT SPECIFIED'
      END
      EOF = FALSE
      MAT ROW = ""

      FOR ROW.NUM = 1 TO MAX.ROWS
         READSEQ ROW(ROW.NUM) FROM PRICE.FILE ELSE EOF = TRUE
      UNTIL EOF
      NEXT ROW.NUM
      IF ROW.NUM < MAX.ROWS THEN MAX.ROWS = ROW.NUM

      IF MAX.ROWS < 5 THEN ERRORS<-1> = "PRICE FILE CONTAINS ONLY ":MAX.ROWS" ROWS OF DATA"
      CLOSESEQ PRICE.FILE
      RETURN




GET.FIELD.DELIMETER.AND.COLS:
      IF LM THEN PRINT "GET.FIELD.DELIMETER.AND.COLS:"
      * TRYING THE COMMON FIELD DELIMETERS UNTIL WE FIND ONE THAT IS MOST PERVASIVE
      MAX.COLS = 0
      FIELD.COUNT.MAX = 0
      FOR DELIMETER.P.X = 1 TO DELIMETER.P.COUNT
         FIELD.COUNT.TOTAL = 0
         MAX.FIELD.COUNT = 0
         FOR ROW.NUM = 1 TO MAX.ROWS
            IF ROW(ROW.NUM)[1,6] <> "***LCS" THEN
               FIELD.COUNT = DCOUNT(ROW(ROW.NUM),DELIMETER.P<DELIMETER.P.X,1>)
               FIELD.COUNT.TOTAL += FIELD.COUNT
               IF FIELD.COUNT > MAX.FIELD.COUNT THEN MAX.FIELD.COUNT = FIELD.COUNT
            END
         NEXT ROW.NUM
         IF FIELD.COUNT.TOTAL > FIELD.COUNT.MAX THEN
            FIELD.COUNT.MAX = FIELD.COUNT.TOTAL
            MAX.COLS = MAX.FIELD.COUNT
            DELIMETER.F = DELIMETER.P<DELIMETER.P.X,1>
            DELIM.F = DELIMETER.P<DELIMETER.P.X,2>
         END
      NEXT DELIMETER.P.X
      IF MAX.COLS < 2 THEN
         ERRORS<-1> = "NO VALID FIELD DELIMETERS RECOGNIZED IN THE FILE"
      END ELSE
         DELIMETER = DELIMETER.F
         DELIM=DELIM.F
      END
      RETURN

ANALYZE.VENDOR:
      IF LM THEN PRINT "*** ANALYZE.VENDOR"
      UPDATE.CODE= FIELD(ITEM.NAME,"_",1)[1,3]
      SELECT.STR = "SELECT TS.VEND WITH ABB = ":UPDATE.CODE
      EXECUTE SELECT.STR
      READLIST VEND.NUMBER THEN
         VEND.NUMBER = VEND.NUMBER<1>
         READ VBUFF FROM TS.VEND,VEND.NUMBER THEN
            UPDATE.NAME = VBUFF<1>
         END
      END
      RETURN



ANALYZE.HEADING:
      IF LM THEN PRINT "ANALYZE.HEADING:"


      DIM CELLS(MAX.ROWS,MAX.COLS)
      MAT CELLS = ""
      DATA.START = 0
      CONSECUTIVE.SAME.LENGTH.COL = 0
      FOR ROW.NUM = 1 TO MAX.ROWS
         SAME.LEN=0
         DATA.LINE = CHANGE(ROW(ROW.NUM),DELIMETER,CHAR(254))
         IF DATA.LINE[1,6] <> "***LCS" THEN
            FOR COL.NUM = 1 TO MAX.COLS
               CELL.VALUE = DATA.LINE<COL.NUM>
               WORD.COUNT = DCOUNT(CELL.VALUE," ")
               FOR WORD.NUM = 1 TO WORD.COUNT
                  WORD = FIELD(CELL.VALUE," ",WORD.NUM)
                  IF NOT(UPDATE.NAME) THEN LOC WORD:"]" IN UPDATE.NAMES SETTING POS THEN
                     UPDATE.NAME = UPDATE.NAMES<POS>
                     VEND.NUM = VEND.NUMS<POS>
                     UPDATE.CODE = UPDATE.CODES<POS>
                  END
                  IF (ICONV(WORD,'D')) THEN
                     DATES.LIST<-1> = ICONV(WORD,'D')
                  END
                  LOCATE WORD IN UM<1> SETTING POS THEN MAST.UOM1<-1> = UM<1,POS>
                  MAST.UOM = MAST.UOM1
               NEXT WORD.NUM
               CELLS(ROW.NUM,COL.NUM)<1> = CELL.VALUE
               IF NOT(DATA.START) THEN
                  IF LEN(CELL.VALUE) > 0 THEN
                     IF LEN(CELL.VALUE) = LEN(CELLS(ROW.NUM-1,COL.NUM)<1>) THEN
                        CONSECUTIVE.SAME.LENGTH.COL<COL.NUM> +=1
                        IF CONSECUTIVE.SAME.LENGTH.COL<COL.NUM> > 4 THEN DATA.START = ROW.NUM - 5
                     END
                  END
               END
            NEXT COL.NUM
         END
      NEXT ROW.NUM
      IF DATA.START = 0 THEN
         ERRORS<-1> = "CANNOT FIND COLUMN WITH AT LEAST 5 CONSECUTIVE ROWS WITH THE SAME LENGTH"
      END
      RETURN





INITIALIZE.COL.METADATA:
      IF LM THEN PRINT "INITIALIZE.COL.METADATA:"

      COL.META = ""
      FOR COL.NUM = 1 TO MAX.COLS
         COL.META<COL.NUM,COL.LETTER.A> = ""         ;* CORRESPONDING LETTER ON AN EXCEL SPREADSHEET
         COL.META<COL.NUM,COL.NUMBER.A> = 0          ;* ORDINAL POSITION OF COLUMN ON SPREADSHEET
         COL.META<COL.NUM,COL.NUM.USED.A> = 0        ;* ORDINAL POSITION OF COLUMN IN RESULTING DATASET OF NON EMPTY COLS
         COL.META<COL.NUM,NAMES.A> = ""              ;* UPC, COST, UOM, C1.COST, EFFDATE
         COL.META<COL.NUM,CURRENCY.QTY.A> = 0        ;* QTY OF VALUES CONSISTENT WITH CURRENCY
         COL.META<COL.NUM,CURRENCY.LOW.A> = ""       ;* LOWEST VALUE IN COLUMN THAT IS  CURRENCY
         COL.META<COL.NUM,CURRENCY.HIGH.A> = ""      ;* HIGHEST VALUE IN COLUMN THAT IS CURRENCY
         COL.META<COL.NUM,CURRENCY.TOTAL.A> = 0      ;* SUM OF ALL CURRENCY VALUES IN COLUMN
         COL.META<COL.NUM,CURRENCY.AVG.A> = ""       ;* AVERAGE OF CURRENCY VALUES FOUND IN COLUMN
         COL.META<COL.NUM,UOM.QTY.A> = 0             ;* QTY OF VALUES CONSISTENT WITH UOM
         COL.META<COL.NUM,MAX.LEN.A> = 0            ;* MAX LENGTH OF VALUE FOUND IN COLUMN
         COL.META<COL.NUM,MIN.LEN.A> = 0            ;* MIN LENGTH OF VALUE FOUND IN COLUMNHOLD ACTUAL VALUES
         COL.META<COL.NUM,LEN.POP.A> = 0            ;* MOST POPULAR LENGTH OF VALUE FOUND IN COLUMN
         COL.META<COL.NUM,ALPHA.A> = 0               ;* QTY OF VALUES THAT ARE ALPHA OR ALPHANUMERIC
         COL.META<COL.NUM,DATE.OLDEST.A> = ""        ;* OLDEST DATE VALUE FOUND IN COLUMN
         COL.META<COL.NUM,DATE.NEWEST.A> = ""        ;* NEWEST DATE VALUE FOUND IN COLUMN
         COL.META<COL.NUM,DATE.FORMAT.A> = ""        ;* CONVERSION CODE USED TO INTEREPRET DATE FIELDS
         COL.META<COL.NUM,DATE.QTY.A> = 0            ;* QTY OF VALUES IN COLUMN CONSISTENT WITH A DATE
         COL.META<COL.NUM,NUM.ONLY.A> = 0            ;* QTY OF VALUES IN COLUMN THAT IS A PURE NUMBER
         COL.META<COL.NUM,NUM.HIGH.A> = ""           ;* HIGHEST VALUE FOUND IN COLUMN THAT IS A PURE NUMBER
         COL.META<COL.NUM,NUM.LOW.A> = ""            ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
         COL.META<COL.NUM,NUM.TOTAL.A> = 0           ;* LOWEST VAUE FOUND IN COLUMN THAT IS A PURE NUMBER
         COL.META<COL.NUM,NUM.AVG.A> = 0             ;* AVG OF VALUES THAT ARE NUM ONLY IN COLUMN
         COL.META<COL.NUM,EMPTY.QTY.A> = 0           ;* QTY OF VALUES THAT ARE EMPTY IN THAT COLUMN
         COL.META<COL.NUM,OCCUPIED.QTY.A> = 0        ;* QTY OF VALUES THAT ARE NOT EMPTY IN THAT COLUMN
         COL.META<COL.NUM,PRED.TYPE.A> = ""          ;* PREDOMINANT TYPE OF VALUE IN THE COLUMN
         COL.META<COL.NUM,PRED.TYPE.QTY.A> = 0       ;* QTY OF ROWS WITH PREDOMINANT CELL TYPE
         COL.META<COL.NUM,CELL.TYPES.A> = ""         ;* ARRAY OF CELL TYPES FOUND IN COLUMN
         COL.META<COL.NUM,CELL.TYPES.QTY.A> = ""     ;* ARRAY OF QTY OF CELLS OF EACH TYPE PRESENT IN COLUMN CORRESPONDING WITH ABOVE
         COL.META<COL.NUM,LEN.TOTAL.A> = 0           ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
         COL.META<COL.NUM,CELL.DATA.A> = ""            ;* ARRAY OF VALUES IN COLUMN
         COL.META<COL.NUM,LEN.TOTAL.A> = 0             ;* TOTAL LENGTH FOUND IN COLUMN, SUM OF VALUE LENGTHS'
         COL.META<COL.NUM,LENGTHS.A> = ""              ;* ARRAY OF LENGTHS FOUND IN COLUMN'
         COL.META<COL.NUM,LENGTHS.QTY.A> = ""          ;* QTY OF ROWS WITH LENGTHS
         COL.META<COL.NUM,LEN.POP.QTY.A> = 0            ;* QTY OF ROWS WITH MOST POPULAR LENGTH OF VALUE FOUND IN COLUMN
      NEXT COL.NUM

      RETURN


ANALYZE.SAMPLE.CELLS:
      IF LM THEN PRINT "ANALYZE.SAMPLE.CELLS:"
      *NOW WE ANALYZE OUR SAMPLE TO SEE IF WE CAN MAP THE STRUCTURE OF THE DATA TO COLUMN NUMBERS
      *FIRST WE LOOK AT EACH COLUMN AND TRY TO CHARACTERIZE THE DATA FOR EACH ONE

      FOR COL.NUM = 1 TO MAX.COLS
         TOTAL.LEN = 0
         TOTAL.DATES = 0

         * SPREADSHEET COLUMN LETTER
         COL.META<COL.NUM,COL.LETTER.A> = CHAR(ASCII.ALPHA+COL.NUM)
         * SPREADSHEET COLUMN NUMBER (ORDINAL POSITION)
         COL.META<COL.NUM,COL.NUMBER.A> = COL.NUM
         LAST.COL.NUM.USED = 0
         FOR ROW.NUM = 1 TO MAX.ROWS
            CELL.VALUE = CELLS(ROW.NUM,COL.NUM)<1>
            COL.META<COL.NUM,30,ROW.NUM>=CELL.VALUE
            IF ROW.NUM => DATA.START THEN
               IF CELL.VALUE THEN
                  * EVALUATE VALUE LENGTH
                  CELL.TYPE=""
                  GOSUB CHECK.LENGTH:
                  IF NOT(COL.META<COL.NUM,COL.NUM.USED.A>) THEN
                     LAST.COL.NUM.USED += 1
                     COL.META<COL.NUM,COL.NUM.USED.A> = LAST.COL.NUM.USED
                  END
                  GOSUB ANALYZE.NUMERIC.ONLY:
                  IF (CELL.TYPE <> "9" AND CELL.TYPE <> '$') THEN
                     GOSUB ANALYZE.ALPHA.ONLY:
                     IF CELL.TYPE = "A" THEN
                        GOSUB ANALYZE.UOM:
                     END ELSE
                        GOSUB ANALYZE.DATE
                        IF CELL.TYPE <> 'D' THEN
                           CELL.TYPE = "S"
                           GOSUB SET.ARRAY.CELL:
                        END
                     END
                  END
               END
            END ELSE
               CELL.TYPE = "E"
               GOSUB SET.ARRAY.CELL:
            END
         NEXT ROW.NUM
      NEXT COL.NUM

      RETURN


CHECK.LENGTH:
      * CHECK LENGTH
      CELL.LEN=LEN(CELL.VALUE)
      IF CELL.LEN > 0 THEN
         COL.META<COL.NUM,OCCUPIED.QTY.A> += 1
         IF COL.META<COL.NUM,MIN.LEN.A> = 0 THEN COL.META<COL.NUM,MIN.LEN.A> = CELL.LEN
      END ELSE
         COL.META<COL.NUM,EMPTY.QTY.A> += 1
      END
      COL.META<COL.NUM,LEN.TOTAL.A> += CELL.LEN
      LOCATE CELL.LEN IN COL.META<COL.NUM,LENGTHS.A> BY 'AR' SETTING POS THEN
         COL.META<COL.NUM,LENGTHS.QTY.A,POS> += 1
      END ELSE
         INS CELL.LEN BEFORE COL.META<COL.NUM,LENGTHS.A,POS>
         INS '1' BEFORE COL.META<COL.NUM,LENGTHS.QTY.A,POS>
      END
      IF COL.META<COL.NUM,LENGTHS.QTY.A,POS> > COL.META<COL.NUM,LEN.POP.QTY.A> THEN
         COL.META<COL.NUM,LEN.POP.A> = COL.META<COL.NUM,LENGTHS.A,POS>
         COL.META<COL.NUM,LEN.POP.QTY.A> = COL.META<COL.NUM,LENGTHS.QTY.A,POS>
      END
      IF CELL.LEN < COL.META<COL.NUM,MIN.LEN.A> THEN COL.META<COL.NUM,MIN.LEN.A> = CELL.LEN
      IF CELL.LEN > COL.META<COL.NUM,MAX.LEN.A> THEN COL.META<COL.NUM,MAX.LEN.A> = CELL.LEN
      RETURN

SET.ARRAY.CELL:
      LOCATE CELL.TYPE IN COL.META<COL.NUM,CELL.TYPES.A> BY 'AR' SETTING POS THEN
         COL.META<COL.NUM,CELL.TYPES.QTY.A,POS> += 1
      END ELSE
         INS CELL.TYPE BEFORE COL.META<COL.NUM,CELL.TYPES.A,POS>
         INS '1' BEFORE COL.META<COL.NUM,CELL.TYPES.QTY.A,POS>
      END
      IF COL.META<COL.NUM,CELL.TYPES.QTY.A,POS> => COL.META<COL.NUM,PRED.TYPE.QTY.A> THEN
         COL.META<COL.NUM,PRED.TYPE.A> = CELL.TYPE
         COL.META<COL.NUM,PRED.TYPE.QTY.A> = COL.META<COL.NUM,CELL.TYPES.QTY.A,POS>
      END
      RETURN


ANALYZE.NUMERIC.ONLY:
      * THE VALUE OF THE CELL IS STRICTLY NUMERIC
      TRIM.CELL = TRIM(CELL.VALUE," ","A")
      IF INDEX(TRIM.CELL,"-",1) = 0 THEN
         IF NUM(CELL.VALUE) THEN
            GOSUB ANALYZE.CURRENCY:
            IF CELL.TYPE <> "$" THEN
               CELL.NUM.ONLY = 1
               CELL.TYPE = "9"
               GOSUB SET.ARRAY.CELL:
               COL.META<COL.NUM,NUM.ONLY.A> += 1
               IF COL.META<COL.NUM,NUM.LOW.A> = "" THEN COL.META<COL.NUM,NUM.LOW.A> = CELL.VALUE
               IF CELL.VALUE <= COL.META<COL.NUM,NUM.LOW.A> THEN COL.META<COL.NUM,NUM.LOW.A> = CELL.VALUE
               IF CELL.VALUE >= COL.META<COL.NUM,NUM.HIGH.A> THEN COL.META<COL.NUM,NUM.HIGH.A> = CELL.VALUE
               COL.META<COL.NUM,NUM.TOTAL.A> += CELL.VALUE
               COL.META<COL.NUM,NUM.AVG.A> = COL.META<COL.NUM,NUM.TOTAL.A>/ROW.NUM
            END
         END
      END
      RETURN


ANALYZE.ALPHA.ONLY:
      * THIS SUB IS ONLY CALLED IF THE VALUE CONTAINS NON-NUMERIC CHARACTERS
      * WE'LL COLLECT ALL THE NON-NUMERIC CHARACTERS IN EACH COLUMN
      CELL.ALPHA.ONLY = ALPHA(CELL.VALUE)
      IF CELL.ALPHA.ONLY THEN
         COL.META<COL.NUM,ALPHA.A>+=1
         CELL.TYPE = "A"
         GOSUB SET.ARRAY.CELL:
      END
      RETURN


ANALYZE.UOM:

      * HAS NO NUMERIC DIGITS SO...
      * CHECKING IF THE CELL CONTAINS A UNIT OF MEASURE DESCRIPTOR
      IF CELL.TYPE = "A" THEN
         UOM.DONE = 0
         FOR UM.X = 1 TO UM.COUNT
            IF CELL.VALUE = TRIM(UM<UM.X>) THEN
               COL.META<COL.NUM,UOM.QTY.A>+=1
               CELL.TYPE = "U"
               GOSUB SET.ARRAY.CELL:
               UOM.DONE = 1
            END
         UNTIL UOM.DONE
         NEXT UM.X
      END
      RETURN

ANALYZE.DATE:
      * IF NOT A CURRENCY THEN CHECK FOR A VALID DATE

      CELL.DATE = 0
      FOR DATE.X = 1 TO DF.COUNT
         CELL.DATE = ICONV(CELL.VALUE,DF<DATE.X>)
         IF CELL.DATE > 0 THEN
            *CELL CONTAINS A VALID DATE
            COL.META<COL.NUM,DATE.QTY.A>+=1
            CELL.TYPE = "D"
            COL.META<COL.NUM,DATE.FORMAT.A> = DF<DATE.X>
            GOSUB SET.ARRAY.CELL:
            IF COL.META<COL.NUM,DATE.OLDEST.A> = "" THEN COL.META<COL.NUM,DATE.OLDEST.A> = CELL.DATE
            IF CELL.DATE < COL.META<COL.NUM,DATE.OLDEST.A> THEN COL.META<COL.NUM,DATE.OLDEST.A> = CELL.DATE
            IF CELL.DATE => COL.META<COL.NUM,DATE.NEWEST.A> THEN COL.META<COL.NUM,DATE.NEWEST.A> = CELL.DATE
         END
      UNTIL CELL.DATE > 0
      NEXT DATE.X
      RETURN


ANALYZE.CURRENCY:
      CELL.TRIM = TRIM(CELL.VALUE)
      CONVERT "$-,+" TO "" IN CELL.TRIM
      IF DCOUNT(CELL.TRIM,".") = 2 THEN
         IF ABS(CELL.TRIM) > 0  THEN
            CELL.TYPE = "$"
            COL.META<COL.NUM,CURRENCY.QTY.A>+=1
            IF COL.META<COL.NUM,CURRENCY.LOW.A> = "" THEN COL.META<COL.NUM,CURRENCY.LOW.A> = CELL.TRIM
            GOSUB SET.ARRAY.CELL:
            CELL.CURRENCY.AMT = CELL.TRIM
            COL.META<COL.NUM,CURRENCY.TOTAL.A> += CELL.CURRENCY.AMT
            COL.META<COL.NUM,CURRENCY.AVG.A> = COL.META<COL.NUM,CURRENCY.TOTAL.A> /ROW.NUM
            IF CELL.CURRENCY.AMT < COL.META<COL.NUM,CURRENCY.LOW.A> THEN COL.META<COL.NUM,CURRENCY.LOW.A> = CELL.CURRENCY.AMT
            IF CELL.CURRENCY.AMT > COL.META<COL.NUM,CURRENCY.HIGH.A> THEN COL.META<COL.NUM,CURRENCY.HIGH.A> = CELL.CURRENCY.AMT
         END
      END
      RETURN


ANALYZE.COLUMNS:
      IF LM THEN PRINT "ANALYZE.COLUMNS:"
      COLUMN.NAMES = ""
      COLUMN.LETTERS = ""
      COLUMN.NUMBERS = ""
      COLUMN.TYPES = ""
      GOSUB IDENTIFY.COLUMNS:

      RETURN
      * TYPES OF VALUES IN EACH CELL ARE: $,9,A,E,D,U,S (CURRENCY, NUMBER ONLY, ALPHA ONLY, EMPTY, DATE, UOM, ALPHA NUMERIC STRING)

PARSE.MAP:
      IF LM THEN PRINT "*** PARSE.MAP"

      VENDOR.UP.LABELS=""
      VENDOR.HEAD.LABELS=CHANGE("UPC.FORMAT,DATA.START",",",@VM)
      VENDOR.UP.VALUES =""
      VENDOR.HEAD.VALUES=""

      IF ROW(1)[1,6] = "***LCS" THEN
         IF LM THEN PRINT ROW(1)
         LCS.LINE = CHANGE(ROW(1),",",@FM)
         LCS.LINE = CHANGE(LCS.LINE,CHAR(9),@FM)
         LCS.LINE = CHANGE(LCS.LINE,":",@FM)
         LCS.CT = DCOUNT(LCS.LINE,@FM)

         FOR LABEL.X = 1 TO LCS.CT
            COL.LABEL = LCS.LINE<LABEL.X>
            IF COL.LABEL = "CATNUM" THEN COL.LABEL = "MFR_CAT_NUM"
            IF COL.LABEL = "EFFDATE" THEN COL.LABEL = "PRICE_EFF_DATE"
            IF COL.LABEL = "COST" THEN COL.LABEL = "CUSTOM_PRICE2"
            IF COL.LABEL = "UOM" THEN COL.LABEL = "CUSTOM_PRICE2_UOM"
            READ DBUFF FROM D.I2PS,COL.LABEL THEN
               IF DBUFF<1> = "D" THEN D.ATT = DBUFF<2> ELSE D.ATT = ""
               LOCATE COL.LABEL IN VENDOR.UP.LABELS<1> BY 'AL' SETTING POS ELSE
                  INS COL.LABEL BEFORE VENDOR.UP.LABELS<1,POS>
                  INS '' BEFORE VENDOR.UP.VALUES<1,POS>
               END
               CV = LCS.LINE<LABEL.X+1>
               IF LEN(CV) = 1 THEN
                  IF ALPHA(CV) THEN
                     CV= SEQ(CV)-ASCII.ALPHA
                     VENDOR.UP.VALUES<1,POS,1> = CV
                     VENDOR.UP.VALUES<1,POS,2>=D.ATT
                  END
               END
            END
         NEXT LABEL.X
         FOR LABEL.X = 1 TO DCOUNT(VENDOR.HEAD.LABELS,@VM)
            IF VENDOR.HEAD.LABELS<1,LABEL.X> THEN
               LOCATE VENDOR.HEAD.LABELS<1,LABEL.X> IN LCS.LINE SETTING POS THEN
                  VENDOR.HEAD.VALUES<1,LABEL.X> = LCS.LINE<POS+1>
               END
            END
         NEXT LABEL.X
      END
      COL.LABELS = VENDOR.UP.LABELS
      COL.VALUES = VENDOR.UP.VALUES
      HEADER.LABELS = VENDOR.HEAD.LABELS
      HEADER.VALUES = VENDOR.HEAD.VALUES
      RETURN

IDENTIFY.COLUMNS:
      IF LM THEN PRINT "***IDENTIFY.COLUMNS:"
      LOWEST.CURRENCY = 0
      EARLIEST.DATE = ""
      LATEST.DATE = ""
      FOR COL.NUM = 1 TO MAX.COLS
         IF COL.META<COL.NUM,COL.NUM.USED.A> THEN
            COL.NUM.USED = COL.META<COL.NUM,COL.NUM.USED.A>
            COL.TYPE = COL.META<COL.NUM,PRED.TYPE.A>
            COL.LETTER = COL.META<COL.NUM,COL.LETTER.A>
            COL.NAME = COL.META<COL.NUM,NAMES.A>
            MAX.LEN = COL.META<COL.NUM,MAX.LEN.A>
            MIN.LEN = COL.META<COL.NUM,MIN.LEN.A>
            AVG.LEN = COL.META<COL.NUM,LEN.POP.A>
            DATE.OLDEST = COL.META<COL.NUM,DATE.OLDEST.A>
            DATE.NEWEST = COL.META<COL.NUM,DATE.NEWEST.A>

            BEGIN CASE
               CASE COL.TYPE = '9'
                  IF MAX.LEN = MIN.LEN THEN
                     IF MAX.LEN = 11 THEN
                        UPC.COL = COL.NUM
                        COL.NAME = "UPC"
                        UPC.FORMAT=''
                     END
                     IF MAX.LEN = 12 THEN
                        UPC.COL = COL.NUM
                        COL.NAME = "UPC"
                        UPC.FORMAT = "[1,11]"
                     END
                     IF MAX.LEN = 10 THEN
                        UPC.COL = COL.NUM
                        COL.NAME = "UPC"
                        UPC.FORMAT = "0+"
                     END
                     IF MAX.LEN = 6 THEN
                        UPC.COL = COL.NUM
                        COL.NAME = "UPC"
                        UPC.FORMAT = "VN+"
                     END
                  END

               CASE COL.TYPE = 'D'
                  EFFDATE = COL.NUM
                  COL.NAME = "EFFDATE"


               CASE COL.TYPE = '$'
                  CUR.AMT = COL.META<COL.NUM,CURRENCY.AVG.A>
                  IF LOWEST.CURRENCY = 0 THEN LOWEST.CURRENCY = CUR.AMT
                  IF CUR.AMT > 0 AND CUR.AMT <= LOWEST.CURRENCY THEN
                     LOWEST.CURRENCY = CUR.AMT
                     COST.COL = COL.NUM
                     COL.NAME = "COST"
                  END


               CASE COL.TYPE = 'U'
                  IF NOT(UOM.COL) THEN UOM.COL = COL.NUM
                  COL.NAME = "UOM"
                  UOM.COL = COL.NUM

               CASE 1
                  IF AVG.LEN > 0 THEN
                     IF AVG.LEN < 30 THEN
                        IF CAT.COL = "" THEN
                           CAT.COL = COL.NUM
                           COL.NAME = "CATNUM"
                        END
                     END
                  END
            END CASE

            IF COL.NAME THEN
               COL.META<COL.NUM,NAMES.A> = COL.NAME
               LOCATE COL.NAME IN VENDOR.UP.LABELS SETTING POS THEN
                  VENDOR.UP.VALUES<POS> = SEQ(COL.LETTER-ASCII.ALPHA)
               END
            END
            COLUMN.NAMES<COL.NUM.USED> = COL.NAME
            COLUMN.LETTERS<COL.NUM.USED> = COL.LETTER
            COLUMN.NUMBERS<COL.NUM.USED> = COL.NUM
            COLUMN.TYPES<COL.NUM.USED> = COL.TYPE
         END
      NEXT COL.NUM

      RETURN


CHECK.ERRORS:
      IF NOT(UPC.COL) THEN ERRORS<-1> = "NO UPC.COL FOUND.  WILL TRY TO FIND CATALOG NUMBER COLUMN"
      IF NOT(CAT.COL) THEN ERRORS<-1> = "NO CATALOG NUMBER COLUMN WAS FOUND"
      IF NOT(COST.COL) THEN ERRORS<-1> = "NO COST COLUMN WAS FOUND"
      IF NOT(UOM.COL) THEN ERRORS<-1> = "NO UOM COLUMN WAS FOUND.  WILL DEFAULT TO USING EA"
      RETURN
