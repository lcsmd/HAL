     SUBROUTINE CREATE.BFILE(BFILE.NAME,OUTARGS)
     PRINT "STARTING CREATE.BFILE"
     LM=1
     ATTS = ""
     TAB = CHAR(9)
     CALL CREATE.BFILE.DICT(BFILE.NAME,OUTARGS)
     OPEN 'ABFILE' TO ABFILE ELSE PRINT 'ABFILE';STOP
     READ FILE.MAP FROM ABFILE,BFILE.NAME THEN
          BFILE.CT = 0
          AFILE.NAMES = FILE.MAP<1>
          AFILE.NAMES.CT = DCOUNT(AFILE.NAMES,@VM)
          DIM FILES(10)
          BFILE.PATH = FILE.MAP<5>
          HEADER = FILE.MAP<7>
          SOURCE.FILES = FILE.MAP<8>
          SOURCE.ATTS = FILE.MAP<9>
          SOURCE.ATTS.CT = DCOUNT(SOURCE.ATTS,@VM)
          OPEN BFILE.NAME TO BFILE ELSE PRINT BFILE.NAME;STOP
          FOR AFILE.X = 1 TO AFILE.NAMES.CT
               AFILE.NAME = FILE.MAP<1,AFILE.X>
               OPEN AFILE.NAME TO FILES(AFILE.X) ELSE PRINT AFILE.NAME;STOP
               AFILE.DICT.KEYS<AFILE.X> = FILE.MAP<2,AFILE.X>
               AFILE.KEY=FILE.MAP<3,AFILE.X>
               AFILE.DESC = FILE.MAP<4,AFILE.X>
          NEXT AFILE.X
          SELECT.STR = "SSELECT ":AFILE.NAME<1,1>:" BY ":AFILE.KEY<1,1>
          PRINT SELECT.STR
          EXECUTE SELECT.STR CAPTURING CAP
          IF LM THEN PRINT CAP
          PRINT
          PRINT "HIT ANY KEY WHEN READY OR Q TO QUIT":;INPUT ANS,1
          IF ANS="Q" THEN STOP
          TXT.FILE.PATH = BFILE.PATH
          DOS.CMD = "DEL ":TXT.FILE.PATH
          IF LM THEN PRINT DOS.CMD
          EXECUTE "DOS /C ":DOS.CMD
          OPENSEQ TXT.FILE.PATH TO BFILE2 ELSE CREATE BFILE2 ELSE PRINT BFILE.NAME:'2';STOP
          WRITESEQ HEADER ON BFILE2 ELSE PRINT "UNABLE TO WRITE HEADER";STOP
          AFILE.KEY.LAST = ""
          SELECT FILES(1)
          LOOP
               CT += 1
               LINE = ""
          WHILE READNEXT LIB.KEY DO
               READ LIB.B FROM FILES(1),LIB.KEY THEN
                    AFILE.KEY = LIB.B<SOURCE.ATTS<1,1>>
                    IF AFILE.KEY <> AFILE.KEY.LAST THEN
                         LINE = LIB.B<SOURCE.ATTS<1,1>>
                         LINE2 = LINE
                         VAL.LEN = LEN(LINE)
                         LAST.SOURCE.FILE = SOURCE.FILES<1,1>
                         IF VAL.LEN > LENGTHS<1> THEN LENGTHS<1> = VAL.LEN
                         FOR ATT.X = 2 TO SOURCE.ATTS.CT
                              CURRENT.SOURCE.FILE = SOURCE.FILES<1,ATT.X>
                              IF CURRENT.SOURCE.FILE <> LAST.SOURCE.FILE THEN
                                   LAST.SOURCE.FILE = CURRENT.SOURCE.FILE
                                   LOCATE CURRENT.SOURCE.FILE IN FILE.MAP<1> SETTING POS THEN
                                        SELECT.STR = "SELECT ":FILE.MAP<1,POS>" WITH ":FILE.MAP<2,POS>:" = ":LIB.KEY
                                        READLIST TEMP.LIST THEN
                                             CURRENT.KEY = TEMP.LIST<1>
                                             READ LIB.B FROM FILES(POS),CURRENT.KEY THEN
                                                  NEW.FIELD = LIB.B<SOURCE.ATTS<1,ATT.X>>
                                                  IF NEW.FIELD = AFILE.DESC THEN AFILE.DESC.VALUE = NEW.FIELD
                                                  GOSUB CHECK.FIELDS:
                                                  VAL.LEN = LEN(NEW.FIELD)
                                                  IF VAL.LEN > LENGTHS<ATT.X> THEN
                                                       LENGTHS<ATT.X> = VAL.LEN
                                                  END
                                                  LINE := @FM:NEW.FIELD
                                                  LINE2 := TAB:NEW.FIELD
                                             END
                                        END
                                   END
                              END
                         NEXT ATT.X
                    END
               END
               WRITE LINE ON BFILE,LIB.KEY
               WRITESEQ LINE2 ON BFILE2 ELSE PRINT "CANNOT WRITE TO FILE";STOP
               AFILE.KEY.LAST = AFILE.KEY

               IF NOT(MOD(CT,100)) THEN PRINT CT:"  ":CURRENT.KEY:" ":
          REPEAT
          OPEN 'BFILE','DICT' TO D_BFILE ELSE PRINT 'D_BFILE';STOP
          TOTAL.LEN = 0
          FOR ATT.X = 1 TO SOURCE.ATTS.CT
               VAL.LEN = LENGTHS<ATT.X>
               FORM = VAL.LEN:"L"
               ATTS.NAME = HEADER<ATT.X>
               TOTAL.LEN += VAL.LEN
               WRITEV FORM ON D_BFILE,HEADER<ATT.X>,6
               PRINT ATTS.NAME "L#25  ":FORM
          NEXT ATT.X
          PRINT
          PRINT "TOTAL MAX LENGTH:":TOTAL.LEN
          CLOSESEQ BFILE2
          PRINT "FINISHED"
          STOP
     END ELSE
          PRINT BFILE.NAME:" NOT FOUND IN DICT ":AFILE.NAME
          PRINT "FINISHED WITH ERROR"
          STOP
     END

FIX.PRICE.SOURCE:
     PRICE.SOURCE = LIB.B<42>
     IF PRICE.SOURCE[1,6] <> "L1425:" THEN
          PRICE.SOURCE = "L1425:0":RIGHT(PRICE.SOURCE,8)
          LIB.B<42> = PRICE.SOURCE
          WRITEV PRICE.SOURCE ON AFILE.NAME,LIB.KEY,42
     END
     RETURN

CHECK.FIELDS:
     IF HEADER<ATT.X> = 'UPC' THEN NEW.FIELD = LEFT(NEW.FIELD,11)
     RETURN
     END
