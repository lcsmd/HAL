* HAL.PROCESS - Main program for processing HAL requests
* Handles incoming requests from the AI server and manages responses
* @param REQUEST - JSON string containing the request data
* @returns JSON response with instructions for the AI server

SUBROUTINE HAL.PROCESS(REQUEST, RESPONSE)
$INSERT COMMON
$INSERT SYSCOM
$INSERT BP OPENQM.RESTFUL.SERVICE

* Initialize response
RESPONSE = ''
STATUS = 0

* Parse JSON request
CALL JSON.DECODE(REQUEST, REQ.OBJ, JSTAT)
IF JSTAT THEN
    RESPONSE = RAISE.ERROR("Invalid JSON request", JSTAT)
    RETURN
END

* Extract request data
TEXT = REQ.OBJ<'text'>
TIMESTAMP = REQ.OBJ<'timestamp'>

* Initialize response object
RESP.OBJ = ''
RESP.OBJ<'use_llm'> = 0  * Default to not using LLM

* Store incoming request in chat history
GOSUB STORE.REQUEST

* Check for specific command patterns
GOSUB IDENTIFY.COMMAND
IF CMD.TYPE # '' THEN
    * Handle specific commands
    GOSUB PROCESS.COMMAND
END ELSE
    * No specific command identified, use LLM
    GOSUB PREPARE.LLM.REQUEST
END

* Encode response as JSON
CALL JSON.ENCODE(RESP.OBJ, RESPONSE, JSTAT)
IF JSTAT THEN
    RESPONSE = RAISE.ERROR("Error encoding response", JSTAT)
END

RETURN

*************************************************************************
IDENTIFY.COMMAND:
* Identify command type from text
CMD.TYPE = ''

* Check for schedule-related commands
IF INDEX(UPCASE(TEXT), 'SCHEDULE', 1) OR INDEX(UPCASE(TEXT), 'REMIND', 1) OR INDEX(UPCASE(TEXT), 'APPOINTMENT', 1) THEN
    CMD.TYPE = 'SCHEDULE'
    RETURN
END

* Check for task-related commands
IF INDEX(UPCASE(TEXT), 'TASK', 1) OR INDEX(UPCASE(TEXT), 'TODO', 1) OR INDEX(UPCASE(TEXT), 'REMIND ME TO', 1) THEN
    CMD.TYPE = 'TASK'
    RETURN
END

* Check for data queries
IF INDEX(UPCASE(TEXT), 'FIND', 1) OR INDEX(UPCASE(TEXT), 'SEARCH', 1) OR INDEX(UPCASE(TEXT), 'LOOK UP', 1) THEN
    CMD.TYPE = 'QUERY'
    RETURN
END

* Check for system commands
IF INDEX(UPCASE(TEXT), 'SYSTEM', 1) OR INDEX(UPCASE(TEXT), 'STATUS', 1) OR INDEX(UPCASE(TEXT), 'HEALTH', 1) THEN
    CMD.TYPE = 'SYSTEM'
    RETURN
END

RETURN

*************************************************************************
PROCESS.COMMAND:
* Process identified command types
BEGIN CASE
    CASE CMD.TYPE = 'SCHEDULE'
        CALL HAL.SCHEDULE(TEXT, CMD.RESP)
        RESP.OBJ<'response'> = CMD.RESP
        
    CASE CMD.TYPE = 'TASK'
        CALL HAL.TASK(TEXT, CMD.RESP)
        RESP.OBJ<'response'> = CMD.RESP
        
    CASE CMD.TYPE = 'QUERY'
        CALL HAL.QUERY(TEXT, CMD.RESP)
        RESP.OBJ<'response'> = CMD.RESP
        
    CASE CMD.TYPE = 'SYSTEM'
        CALL HAL.SYSTEM(TEXT, CMD.RESP)
        RESP.OBJ<'response'> = CMD.RESP
        
END CASE
RETURN

*************************************************************************
PREPARE.LLM.REQUEST:
* Prepare request for LLM processing
RESP.OBJ<'use_llm'> = 1

* Get conversation history
HISTORY.SIZE = 5  * Number of previous exchanges to include
GOSUB GET.CHAT.HISTORY

* Construct prompt with context
PROMPT = "You are HAL, an AI assistant. "
PROMPT := "Use the following conversation history for context:":CHAR(10)
PROMPT := HISTORY:CHAR(10):CHAR(10)
PROMPT := "Current user request: ":TEXT:CHAR(10)
PROMPT := "Respond naturally and conversationally as HAL."

RESP.OBJ<'prompt'> = PROMPT
RESP.OBJ<'model'> = 'mistral'  * Default model
RETURN

*************************************************************************
STORE.REQUEST:
* Store request in chat history
OPEN 'HAL.CHAT.HISTORY' TO F.HISTORY ELSE
    CREATE F.HISTORY ON ''
END

* Generate unique ID for chat entry
NOW = OCONV(DATE(), 'D4/') : TIME()
CHAT.ID = NOW : '-' : RND(99999)

REC = ''
REC<1> = TEXT            * Request text
REC<2> = TIMESTAMP       * Unix timestamp
REC<3> = 'USER'         * Speaker
REC<4> = CMD.TYPE       * Command type if identified

WRITE REC TO F.HISTORY, CHAT.ID
RETURN

*************************************************************************
GET.CHAT.HISTORY:
* Retrieve recent chat history
HISTORY = ''
SELECT F.HISTORY TO SEL.LIST
READLIST CHAT.IDS FROM SEL.LIST ELSE CHAT.IDS = ''
CNT = DCOUNT(CHAT.IDS, @AM)

FOR I = CNT TO CNT-HISTORY.SIZE+1 STEP -1
    IF I < 1 THEN BREAK
    CHAT.ID = CHAT.IDS<I>
    READ REC FROM F.HISTORY, CHAT.ID ELSE CONTINUE
    
    SPEAKER = REC<3>
    MSG = REC<1>
    
    HISTORY := SPEAKER : ': ' : MSG : CHAR(10)
NEXT I
RETURN

*************************************************************************
RAISE.ERROR:
* Create error response
ERR.MSG = SENTENCE
ERR.CODE = STATUS
ERR.OBJ = ''
ERR.OBJ<'error'> = ERR.MSG
ERR.OBJ<'code'> = ERR.CODE
CALL JSON.ENCODE(ERR.OBJ, ERR.JSON, JSTAT)
RETURN ERR.JSON
