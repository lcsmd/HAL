{
    "PUPO2tTyPOo": {
        "title": "AutoGen Advanced Tutorial - Build Incredible AI AGENT Teams",
        "thumbnail": "https://i.ytimg.com/vi/PUPO2tTyPOo/hqdefault.jpg",
        "author": "Matthew Berman",
        "date_of_release": "2023-10-26T14:08:15Z",
        "duration": "PT38M8S",
        "view_count": "110287",
        "like_count": "3279",
        "comment_count": "257",
        "description": "In this video, I break down every topic you need to know to become an AutoGen master. Some topics include caching, best practices, enhanced inference, multi-agent setup, LLM daisy-chaining, a brand-new agent type called Teachable Agent, function calling, templating, and so much more. \n\nEnjoy :) \n\nJoin My Newsletter for Regular AI Updates üëáüèº\nhttps://www.matthewberman.com\n\nNeed AI Consulting? ‚úÖ \nhttps://forwardfuture.ai/\n\nRent a GPU (MassedCompute) üöÄ\nhttps://bit.ly/matthew-berman-youtube \nUSE CODE \"MatthewBerman\" for 50% discount\n\nMy Links üîó\nüëâüèª Subscribe: https://www.youtube.com/@matthew_berman\nüëâüèª Twitter:  https://twitter.com/matthewberman\nüëâüèª Discord: https://discord.gg/xxysSXBxFW\nüëâüèª Patreon: https://patreon.com/MatthewBerman\n\nMedia/Sponsorship Inquiries üìà\nhttps://bit.ly/44TC45V\n\nLinks:\nUse RunPod - https://bit.ly/3OtbnQx\nAutoGen Beginner Tutorial - https://www.youtube.com/watch?v=vU2S6dVf79M\nAutoGen Intermediate Tutorial - https://www.youtube.com/watch?v=V2qZ_lgxTzg\nAutoGen Fully Local - https://www.youtube.com/watch?v=10FCv-gCKug\nAutoGen 100% Open-Source - https://www.youtube.com/watch?v=FHXmiAvloUg\nAutoGen - https://microsoft.github.io/autogen\n\nChapters:\n0:00 - Intro\n0:56 - LLM Config\n6:47 - Config List\n10:54 - Caching\n13:31 - Enhanced Inference\n19:36 - Templating\n21:20 - RAG Agents\n26:20 - NEW Teachable Agent\n31:35 - Using Docker\n32:57 - Function Calling\n36:07 - Agent Tool Learning",
        "transcript": "welcome back today we have another video on autogen this is the advanced tutorial we're going to go over a ton of different topics I'm going to go in depth I'm going to show you some code I'm going to go through the documentation and by the end of this video you're going to be able to build incredible things with autogen and I realized while doing the research for this video there's topics in autogen that are expert level and weren't another video so I'm going to be creating another video an expert tutorial for the remaining top ipcs that I don't cover in this video but for this video I'm covering almost everything in autogen and it turns out autogen has a ton more functionality than I even realized when I first started playing with it in fact it is incredible as a dropin replacement for your chat GPT API if you want to use that and stick around to the end of this video because we actually have a brand new agent type that we're going to be talking about that was just released by the autogen team so let's go all right the first thing I want to talk about is the llm config and the config list parameters and the config list parameter is something that's passed into the llm config first let's start with llm config that is something that is passed to each agent and it doesn't matter if you're creating an assistant agent or a user proxy agent they all take llm config and there's a bunch of different settings that you can play around with for llm config so here's a few of them the main thing that you're going to be passing into the llm config is the config list and that's where you define which models that you want to use and how to set up those models and you can have a daisy chain of models that you want to use so let's say you start with GPT 4 then you have an open source model then you go to GPT 3.5 and it'll actually fall back depending on if it gets an error or not but you have some additional functionality that you can put in llm config so here's the first one context and if you're going to be using prompt templates this is where you'll be defining the keys for that template now I'm just going to touch on prompt templates and I'll probably save the actual ual deep dive into prompt templates for the expert tutorial so here's an example if your prompt is complete the following sentence and then this prefix you can actually pass in the prefix just like that so you say the prompt here it is then you pass in the context equals and then you pass in the keys so prefix is today I feel and then here it says the actual prompt will be complete the following sentence today I feel so the context is where you can Define different variables to insert into the pr so here it is problem how many positive integers not exceeding 100 are multiples of two or three but not four and then the actual prompt is right here and we insert the problem which is defined in the context into the prompt and then we end with solve the problem carefully we can also say solve the problem step by step and that just makes it super easy to create different prompt templates for different agents so you're not rewriting the same thing over and over again next is a use cach flag and that allows you to either use the cash or not so by default cash is enabled so if you don't put anything it's going to be enabled but if you don't want to use the cash such as if you're doing a lot of testing and you actually want to see the replies back from chat GPT or your open source model then you would turn that to false and it's true or false it's a Boolean and then like I mentioned config list and this is a list of configurations for the completion to try the first one that does not raise an error will be used so that's where as I mentioned you put your daisy chain of large language models that you want to use and all the settings associated with them but this is also where you're going to include your function definitions and one of the most powerful features in autogen is its ability to use function calling and if you're not familiar with function calling it's just a way for you to predefine functions for your autogen or large language model to use so you can predefine functions in a certain format and then you can actually write the functions in the code and then the large language model can use those functions based on the definition and based on executing the code now I'm going to get into function calling later in this video so that's all I'm going to say about it now but in the llm config that is where you're going to put all your function definitions and here's another setting that's super useful raise on rate limit or timeout now I frequently get rate limit issues with chat GPT now obviously you're not going to get this if you're running an open source model but if you're using chat GPT either 3.5 or 4 you're going to get rate limit issues if you're using it too often typically I'm getting a Tok per minute rate limit and so what you can do here is you can set this to true or false when it's true it's actually going to raise an error and the code execution will stop but if it's false then negative -1 it says right here negative 1 will be returned when all configs fail so it's going to go through the list of different llms that you've provided and if all of them fail it's not actually going to raise an error it's just going to return negative 1 and that allows you to include your own Logic for what you want to happen if you run out of large language models to hit because you keep getting errors and then another option you get is this config parameter so and this is specific to the open AI API and it allows you to pass in different parameters that are used with the openai API and then in addition to those you also get these three which are Max retry period which is the total time and seconds allowed for retrying failed requests so if you don't want it to just continue retrying indefinitely you can actually set a time limit on the retries let's say 15 or 30 seconds then you have the retry wait time and this is the time interval to wait in seconds before retrying a failed request one thing that it would be nice is if you had an exponential back off which I'm not sure you do because this is just a single integer so this is like every 3 seconds you want to wait or every 10 seconds you want to wait before retrying again whereas it would be super nice if you can actually say Okay 1 second 5 Seconds 20 seconds 2 minutes 6 minutes but I think at a certain point it doesn't make sense to just continue waiting and then you have the seed for the cash and the cash is super important I'm going to touch on cashing in a few minutes but this allows you to set the seed value for a cash so the cash is specific to that seed I think by default the example they give is 42 so if you run a prompt with the seed of 42 twice you don't actually have to hit the open AI API a second time or whatever llm you're using it's just going to use the cach version if you change that to 41 or 47 or two anything else it's going to recash it so that's an excellent way to control your budget and to control caching and as I mentioned you can pass in all the different values that you normally can with chat gpt's API so you have the model The Prompt the messages the max tokens temperature top PE and stop presence penality frequen penality and best of so you can pass all of those in I'm not going to go over those cuz those aren't really specific to autogen all right now let's talk about the config list this is where you're going to Define all of the large language models that you want to use whether it's an open source model or a chat gbt model and you can do this in a number of ways you can do this directly in the code or you can have a separate Json file that gets loaded into the config list so if you're going to be loading it in from a Json file you're going to be using this right here config list from Json and you're going to call it o AI config list you're going to define the file location just like that and you can either have it locally or if this is deployed to a production server you just list the URL of where to find it and then you have the filter dict right here and the filter dict just tells autogen Which models to look for and so here's what the oi config list looks like you don't need to have it as a separate file you can literally just pass it directly in but if you wanted to this is what it looks like so this is daisy chain so it's going to try gp4 first with this API key then it's going to try gp4 again except this time it's going to use the Azure open AI API key and then last it's going to try GPT 3.5 turbo and it only goes to the next one if the first one doesn't give a valid reply such as if it fails or it times out for each each of them you can include the model the API key your API base which is the URL the API type so here it says Azure but typically you're just going to use the open AI API type especially if you're using an open- Source model you just want to keep it standard with the open AI API type and then you can have the API version right here and by default it uses the open AI API base so if you did want to use an open source model for the base you would put the URL of the endpoint that you're using whether it's a local server or you have it on something like runpod you would put it right there now I've already created two videos on how to get it set up locally and on runp pod I'll link those in the description below so you know how and let's put it all together we have the llm config which gets passed into the assistant agent or the user proxy agent and as one of the values if we're keeping everything else as default we just pass in the config list to the config list key now of course all the previous stuff I mentioned with llm config you can do that at the same time and the nice thing is you can pass all of the llm configs and thus the config list into each individual agent so you can have different settings for every agent and a good use for that is if you're running open source models so let's say you have a really complex task that you're trying to set up let's say you have a team of agents and you have a coding agent you have a creative writing agent and then you also have one that needs to do function calling and typically open- Source models are fine-tuned to be good like one thing and with autogen that's actually a benefit so you can actually choose the right model for the right task you can choose the creative writing model for the creative writer you can choose the coding model like code llama for the coder and so on so here's some code let's actually see what this looks like so we have two config lists here we have the CL config list which is code llama so I specified our local model code llama I put in a fake API key and then for the API base let's say I have have code llama spun up on a local server and it's Port 3000 then I can actually have a second server mistal config list and we're going to be using mistal 7B another fake API key and then here I'm putting it on Port 3001 so now I have two different models that are spawn up running locally and I can actually assign them to different agents so here we have our typical user proxy agent and then for the coder agent I'm passing in the config list is CL config list which references this one right here code llama and then for the assistant agent of the product manager I'm using mistol so I'm going to pass in the mistal config list and you can get as sophisticated as you want here you can have a dozen different models but of course you need to figure out how to run them locally and you need to have a powerful enough GPU to run all of them and you can also mix and match between closed source and open source models the possibilities are truly endless all right now let's talk about caching caching can be used both on the agent creation and definition side as well as the drop in open AI replacement side in the llm config shown here we have this parameter seed and we're going to pass in the number 42 so let's talk about what this does for a minute now in the context of agents this is how you use it all you need to do is include this little seed parameter here in the llm config so you pass in the config list as normal and then you pass in seed and what that's going to do is look over here on the left we have aach folder followed by the number 42 and within that we have a database cache.db and that saves the entire exchange based on the initial prompt and so why would you need a cash well the good thing is if you're running the same task over and over again for testing purposes or even in production if you have everything cashed you're going to save both time and money because in the case of a closed Source model like open AI you don't actually have to hit that API M Point again and again if you're using the same prompt and the same seed then it'll just output the same EX exact output as it has cached and in the case of an open source model where cost isn't as much of a factor you're going to save a lot of time because it doesn't actually need to run the inference against the prompts again because it already has it now there's a few ways to clear the cash number one very simple right click on the cach directory and just click delete you can also delete specific seeds so you can right click on the 42 or whatever number you decide and you can delete it from there and then the next time you run it it's going to recash it another way to do it is to Simply change the seed value right here so if we want to save that cash but create a new cash we can change it to 43 we can change it to 123 we can change it to anything we want and if it's a new seed and it has no reference to that seed it's going to recash everything and run it from scratch and on the enhanced inference side which we'll get to in a minute which basically means autogen can be used as a dropin replacement for the open AI API because it's essentially just a wrapper around that with a tonon of additional tools and functionality that are very very useful you can use caching just the same so if you execute the same exact prompt to chat GPT you won't actually need to hit the API endpoint a second time if the seed is the same and the prompt is the same it works just the same as the agent side and it also has these Nice Class methods so if you're using this you can use this set cach manually so this allows you to set the cach with a seed and then it also allows you to clear a cache but of course you can simply delete it manually as well like I showed you now let's talk about enhanced inference now autogen really has two main parts to it it has the multi-agent conversation framework and that's really what it's known for basically being able to Define agents that work together to complete tasks but it has this whole separate thing called enhanced inference and I didn't even realize how powerful enhanced inference was until I started digging into it and it truly is a major pillar of the autogen framework so let's read a little bit about it and then I'm going to talk about it enhance inference so autogen do completion is a dropin replacement of the open aai completion and open AI chat completion for enhanced llm inference basically what that means is if you're using the open aai API for completion for inference you can easily just use autogen and get all of this additional functionality and you don't even need to change your code if you already have a codebase setup with open ai's API so there are a number of benefits of using autogen to perform inference Performance Tuning API unification caching error handling multi-c config inference result filtering templating and so on it is really really powerful and I was thinking about this why would they have done this it seems to me like the main functionality for autogen is the multi-agent framework but as I was thinking about that to make that multi-agent framework super powerful actually having all of this additional functionality on the open AI API endpoint is really powerful for the agents and they probably built it and said oh look at all this functionality we should just also package this up as part of autogen so I think that's what happened I don't actually know and the first thing that we're going to talk about within enhanced inference is the performance tuning and that basically means finding the best settings for the large language model that you're using and so here it says the tunable hyperparameters include the model The Prompt the max number of tokens the temperature top p and stop presence penality frequence penality and best of so it will automatically adjust all of these settings depending on what your goal is and depending on what the evaluation method is and so here it explains it really well the cost of using Foundation models for text generation is typically measured in terms of the number of tokens yeah so we knew that from the perspective of an application Builder using Foundation model so a developer the use case is to maximize the utility of the generated text under an inference budget constraint measured in the number of dollars to solve the task successfully so let's say you have a task to create a piece of code that outputs something you can actually provide an evaluation method that tests whether the output is correct based on that code and then you can tune all of these different settings to figure out okay based on what I'm tuning what is the lowest dollar value that I can actually get this task completed within and so there are five pie of information that tuning can be performed on the validation data the evaluation function the metric to optimize the search space and the budget and we're going to talk about all five of those first the validation data this is basically a set of data that shows what a successful performance looks like now I'm not going to go too deep into Performance Tuning because this is really complex stuff and I'm going to save that for the expert video and to be honest I'm still wrapping my head around it so after the valid validation data we're going to have the evaluation function and this is a function that's defined by you that evaluates whether the output is successful or not so here we have evaluate math responses and we have the answer from the llm and then we say return success and then we have this evaluation function is equivalent and we pass in the answer and the actual solution and then we compare them against each other and if the answer that the large language model gave us and the answer we know to be correct is equal then we pass back success and what that'll do is once we pass it back it informs the enhanced inference that that set of variables was successful within that budget then we have the metric to optimize and it says here the metric to optimize is usually an aggregated metric over all the tuning data instances for example users can specify success as the metric and Max as the optimization mode by default the aggregation function is taking the average and then we have the search space so basically which parameters do we want to test against so we can test against the model The Prompt the max tokens etc etc and then we give it a budget and the budget is going to be in dollar so it's going to try to find the successful combination of different parameters to get the correct output but to do so within a given budget and again the budget is in dollars and it's dollars per 1,000 tokens and here's what the actual completed code looks like so we have a config and Analysis autogen do completion. tune so we have our tuning data we have our metric of success that's what we're measuring against we want to maximize it and then we have our evaluation function we have our inference budget of 5 cents so 5 cents per 1,000 tokens we have our optimization budget of $3 and then the number of samples and we can sample a fixed number but if it's NE -1 it's going to be unlimited it'll test everything so another really good thing for enhanced inference is that you can use one API endpoint now and get a bunch of different models and that also includes local models so with this one endpoint we can use text Vinci O3 GPT 3.5 turbo and GPT 4 and we can also use local llms they suggest using fast chat I used LM studio and runpod using test generation web UI again videos will be in the description below and just like we did on the agent side we can have a daisy chain of models to use and when one fails we go on to the next one or we can even specify different models for different types of Agents and we don't need to change the actual API code at all that's why it's super powerful for API unification another thing that we can do with enhanced inference is templating and templating just allows us to write less code and more prompts so when would we actually use templating why would we actually use it well one example is if you've ever watched any of my llm testing videos you notice that in a lot of the prompts I put at the end explain your reasoning step by step and what I found is is when I put that I get better answers from the large language model and so rather than having to put explain your reasoning step by step at the end of every prompt in autogen we can just create a template from that and we can have the problem we can actually have the task that we want to execute and then we'll add in explain your reasoning step by step at the end of that so here's an example of how that would work here's the context and this is the problem we're looking to solve so how many positive integers not exceeding 100 are multiples of two or three but not four now in the prompt we pass in that problem right here and then we add solve the problem carefully rather than solve the problem carefully that's where we would actually put explain your reasoning step by step I think effectively they're trying to do the same thing but that's what I use is explain your reasoning step by step and then you want to add this allow format string template equals true to make sure that it gets inserted properly so that is really really powerful and I encourage you to play around with templates and then last we have logging it does say logging is experimental but it seems to work just fine so when you have your instance of autogen you just do autogen chat completion start logging and then you can do all your inference calls like normal and then at the end you can actually get the logged history and look through exactly what happened with all of the API calls which is nice for debugging okay our next topic is rag agents that's retrieval augmented generation that means that you have some external data source typically in the form of embeddings and our agents are actually able to pull knowledge pull information from those sources and this makes them incredibly powerful and based on our initial two types of Agents we have our assistant agent and user proxy agent we just add retrieve to the beginning of those to make them retrieval augmented agents so retrieve assistant agent and retrieve user proxy agent so let's look at an example from the documentation we have our normal assistant agent right here and then we have our retrieve user proxy agent right here so we're giving our user proxy agent the power of rag and we pass in this retrieve config parameter that takes the task type so here's QA which is question answer and then we have our docs path and here it's passing in this read me file so now this user proxy agent has access to the information contained within this file and by default it chunks everything for us it converts it to embeddings it's stores it in a vector database all by default all automatically and of course we have full control over all of these settings let's continue with this example though so we have the rag proxy agent and we're going to initiate chat and what is autogen now here's the output autogen is a framework that enables the development of large language model applications using multiple agents that can converse with each other so exactly what we would expect because it has access to that documentation now we're going to create a regular user proxy agent it's not going to have access to that information and we're going to see the difference in responses so here the output is in computer software autogen is a tool that generates program code automatically without the need for manual coding it is commonly used in fields of software engineering blah blah blah so basically not the right answer because it has no notion of what autogen is in the original large language model knowledge set and so now you can give specific agents a ton of additional information that it doesn't have in its initial data set so let's talk about customizing retrieval agents so customizing embedding function by default sentence Transformers and its pre-trained models will be used to compute the embeddings and quickly the embeddings are just taking text and converting them to vector format that allows relevant search to be really easily done but you can easily customize the embeddings function you can use a different model a local model you can use chat gpt's embedding functions you can use anything you want so here's an example from open AI we have our embedding functions defined in this object right here then we pass in that open aior EF right there in our embedding function so everything goes within this retrieve config we still pass it the task the docs path and the embedding function is something new right here we can see we're using hugging face the same way so if we don't want to use open AI we can use hugging face and you can also customize the text split function and the text split function is basically our chunking method and I usually don't change this but but you can if you want to so in this example lank chain has a text splitter and we can use all the different text Splitters in lank chain so we can just Define it and then pass it into this custom text split function so then when it actually goes to execute it's going to execute the text splitting through this function right here defined here we can also customize our Vector database by default it uses chroma DB but you can use pine cone you could use anything else that you want and in this example they're using cudr so same thing we Define cant as a client and then we rewrite our query Vector database method this is all just custom code if we wanted to write that ourselves but then at the bottom in this retrieve docs method that's actually overwriting the default retrieve docs method and that's how you can customize which Vector database you use and again going really deep into this I'll probably save for the expert tutorial but now you kind of get the gist of how this all works you can customize absolutely everything and here here is a sophisticated example integrating retrieval agents with other agents in a group chat so like normal we have the llm config and here we Define functions I'll touch on that in a minute everything else stays the same we have the boss who's a normal user proxy agent and then we have the retrieve user proxy agent so this is a user proxy agent that also has the ability to gather information from external data sources and we want code execution to be false because we just want them to pull information and we want want the user proxy agent the standard one to be doing the code execution and we pass in the retrieve config then we have the assistant agent another assistant agent and another assistant agent and this is going to be a coding team and so we can have certain agents that are retrieval certain agents that are not and they're all working together and the way we actually kick it off is with the boss and the boss is the standard agent and there we go okay so we talked about a few different types of Agents so far we talked about the conversible agent which which includes the assistant agent and the user proxy agent we also talked about rag agents which have the ability to pull information from documents and now as of a few days ago we have a brand new agent type called the teachable agent and the teachable agent you're actually able to give it information that it learns stores in long-term storage and has even after the chat conversation ends so typically if you're giving information to an agent it doesn't have that information once that task is completed or once that chat is closed but now with the teachable agent we can always call the teachable agent which will have that information forever and so we Define a teachable agent in the same way we Define our other types of Agents so right here just like that but rather than saying user proxy agent or assistant agent we use teachable agent and we have this teach config and for the teach config we have a few parameters we have the verbosity which is optional and we have zero for passing it basic information one to add memory operations and two for analyzer messages and three for memo list we have reset DB so if we put true it's going to use a new database every single time and of course if we actually wanted to learn something over time we set that to false or just leave it blank then we have our path to the DB directory again another optional parameter this is a path to the directory where the database is stored the nice thing is autogen creates the database for us we don't need to worry about it we can also prepopulate the database with information so we don't actually need to go through the agent interface a conversation to give it additional information so we could do that here and then we have the recall threshold which is the maximum distance for retrieved memos where 0.0 is exact match and larger values allow for more memories to be retrieved and then we have the max number of retrievals all of these are optional so let's look at an actual example cuz I know this is a little confusing so back here we have our teachable agent we're passing it our teach config our teach config here for Robos zero we're just passing it basic information we are going to reset the database so it's going to start from scratch here's the path to the database right there and then we have our recall threshold this is the default value anyways but higher numbers allow for more but less relevant memos to be recalled now let's teach it new facts so here we say what is the vuna model and we initiate the chat and it says I'm sorry but I don't have information because we haven't taught it anything then next we do the same thing we initiate the chat but but we actually tell it what it is vuna is a 13B parameter language model released by meta and now we set clear history to false although that is the default I believe and now when we ask it the same question it says thank you for providing that information the vun model is a large scale language model developed by meta and a bunch of other information same thing here what is the Orca model and then here it tries to guess what the Orca model is based on knowing what the vuna model is but it's not really an accurate answer the Orca model is a yet to be released language model by meta referring to the research preview API release of meta's advanced language model I don't have specific details Etc but now we're actually going to tell it Orca is a 13B parameter language model released by Microsoft that outperforms vuna on most tasks now it has that information and so let's see it again now let's start with a new chat by clearing the previous chat's history at this point common llm base assistants would forget everything but the teachable agent can retrieve memory is from the vector database as necessary so here we go how does the Funia model compare to the Orca model so we have no chat history but what it can do is it can pull from its Vector database of memories and here we go it actually gives us a legitimate correct answer amazing and you can not only pass it memories but you can actually have it learn your preferences and here we can actually call something interesting learn from user feedback so as the user is giving feedback to the model and let's say you have the feedback set to always every single iteration it's going to ask you for feedback here it can actually learn from your feedback and store only the relevant memos so let's say you prefer short answers or you prefer very verbose answers you can teach it to the teachable agent and the teachable agent will work with the user proxy agent will work with the assistant agent to make sure you're getting the responses that you want so here's an example please summarize this abstract so we have the abstract right here and here's the the teachable agents output which is just unstructured information so then it says when I'm summarizing an abstract I try to make the summary contain just three short bullet points and here it says okay thank you and then the teachable agent now says title Innovation and key empirical results and that is the format that we asked it to provide in so the teachable agent is brand new I'm still learning more about it and I'm going to include more information in that expert tutorial and I know this is a long video there's a lot to cover and I really probably didn't dive deep enough into any of these topics so let me know in the comments if you want me to expand on any of these topics in the expert tutorial that I'm going to create so code execution and Docker Docker by default is turned on but you also have to have it installed and the way to do that is very simple you need to do pip install Docker like normal to make sure you have the docker Library installed and as I mentioned Docker is enabled by default and if you don't have Docker installed even if you have Docker enabled autogen is smart enough to fall back and it says hey we looked for Docker it's not there so we're going to execute the code without Docker now right here it says we strongly recommend using Docker to execute code now there's a reason for that you're having artificial intelligence right code and execute code on your local machine in most cases so of course you want to dockerize that and have it in an enclosed environment just in case right and there's two ways to do it you can either run the entire Auto gen project from within a Docker image which is typically how I do it or you can run it outside of Docker and then only have the code execution work within Docker and they show how to do that here so enable Python 3 Docker image and here in the code execution config we have our work directory so that's where all the code gets output or any output gets stored and then we have this used Docker python colon 3 and that's it that's Docker and I do recommend just just like they do use Docker as much as possible okay there's actually two more things that I want to show you today the first thing is function calling one of the most powerful pieces of functionality for any large language model is function calling and basically what function calling is is you have a definition of a bunch of different functions that you might want the large language model to be able to use and execute and then you can actually Define what those functions look like so let me show you an example so here as mentioned in the llm config you're going to have a functions key within the functions key you're going to Define what the functions look like and in this example we have two we have one called Python and one called sh so we have the name description parameters that are going to be passed into this function and we have that for both so you're basically setting up what the actual function is going to look like then down here we Define the functions in our actual code not an autogen we Define our functions according to the function description so we have exec python we pass in cell just like we just defined we have our actual code and same thing with execs and so what this allows us to do is build a ton of additional functionality for our agents we can really Define any function to give them additional Powers then we have to actually register the functions so here when we say user proxy we're going to register function we're going to pass in a function map we have Python and Sh which refer to the different names right here Python and Sh in our functions llm config and then we pass in the actual function name so exec Python and exec sh and those are the ones that are actually written and defined right there and then we can actually use it so we have user proxy initiate chat like normal chatbot and the message draw two agents chatting with each other with an example dialogue don't add PLT doow and the chatbot to the user foxy says suggested function call Python and so now it knows how to put together a function call to that python function Now function calls can get extremely complicated and I'm not going to go too far into it I'm probably going to do a much deeper dive in the expert tutorial so here's one more example of function calling we're going to be calling the Wolfram Alpha API so we Define the function here query Wolfram we put a description we talk about the parameters that we're going to be passing in and the required parameter called query here we have the function map query wol from math user proxy agent so this is actually from the wol from alpha API and then we start the conversation so problem find all that satisfy the inequality and then we pass in a math function express your answer in interval notation and so we already have this execute one wol from query as part of the math user proxy agent that we're pulling in and that's something predefined in autogen so let's see what it actually outputs problem here's the problem then it's suggest suggested function call so it realizes okay I need to use Query Wolfram it passes in the required query parameter here it is and then it actually calls it and then we get the output so it is beautiful it works flawlessly okay the last thing I want to show and this is not necessarily something that's built into autogen autogen just happens to be really capable with learning new tools and that is exactly what we're going to be looking at teaching the agents to use new Tools in this example we set up everything like normal we have a standard assistant agent a standard user proxy agent and our task is to find archive papers that show how are people studying trust calibration in AI based systems so it does that no problem writes the code queries archive gets the answers then we give it some feedback and we have task two analyze the above results to list the application domains okay writes more code does that then we say use this data to generate a bar chart so we give it a bunch of tasks in a row and it creates python method methods to execute that it fails at times the user proxy agent gives it feedback and it fixes the code but here's where the special part comes right here task four reflect on the sequence and create a recipe containing all the steps necessary and name for it so basically what it's saying is find exactly what worked in the previous few steps and redefine it remove anything that didn't work and put it all in a single file and now that's what we have right here and then going forward what we actually do is we actually put that entire recipe in the task itself but we don't just have to do that now with the teachable agent we can actually give it the recipe to store we don't actually have to include it in the task definition itself and we can also store it in a database we can store it in a local file and just tell any other agent how to pull from that file so it's extremely extremely powerful okay that's it for today this was an extremely long video but hopefully you learned enough where now you can consider yourself an advanced autogen user if you liked this video and you want to get notified about the expert tutorial be sure to like my video be sure to subscribe and I'll see you in the next one"
    }
}